<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Homepage</title>
    <link>/post/</link>
      <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 22 Oct 2018 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Posts</title>
      <link>/post/</link>
    </image>
    
    <item>
      <title>Secure Two-Party Computation (S2PC)</title>
      <link>/post/s2pc/</link>
      <pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate>
      <guid>/post/s2pc/</guid>
      <description>

&lt;p&gt;Not to toot my own horn here but when I was in high school I used to be quite popular :). I was moreover one of the least shy people I know but when it came to girls, I was interested in, I suddenly turn to this timid shell of a person. This awkward version of a popular guy is not uncommon and the fear of rejection is the reason that rattles us to the core. I still remember this girl from my high school I’ve never talked to, because of that fear — let’s call her &lt;em&gt;Lalla Salma&lt;/em&gt; in the sequel (Any resemblance to actual persons, living or dead, is purely coincidental). No matter how much courage I’ve summoned and how firmly I’ve convinced myself I don’t care about the outcome, hearing no from &lt;em&gt;Lalla Salma&lt;/em&gt; would have hurt. A graceful no hurts a great deal less but a cruel no in public drives a knife through the male psyche.&lt;/p&gt;

&lt;p&gt;Growing up, I became a cryptographer and figured out a mathematical way to deal with such a situation. How can you make secure advances to &lt;em&gt;Lalla Salma&lt;/em&gt; ? Is there a way to securely guess the outcome ? or simply put, how can you avoid a dismissive no in public ? The solution uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Garbled_circuit&#34; target=&#34;_blank&#34;&gt;Yao’s Garbled circuits&lt;/a&gt; for secure two-party computation (S2PC).&lt;/p&gt;

&lt;p&gt;Given private inputs $x$ and $y$ and a public function $f$, this method enables two parties to securely compute the outcome $f(x,y)$ without revealing the secrets $x$ and $y$. A circuit is just a way to represent a computation consisting of just operations on bits, like AND, OR, NOT and a garbled circuit is a way to “encrypt a computation” that reveals only the output of the computation, but reveals nothing about the inputs or any intermediate values. Our situation makes the basic way to understand how the protocol works. Let the secret $x$ be 1 if I am interested in &lt;em&gt;Lalla Salma&lt;/em&gt; and 0 otherwise. Similarly, her secret $y$ is either 1 or 0. We want to securely compute a function that outputs 1 if we both are interested in each other and 0 otherwise — no one should be able to guess the inputs. A simple function would be an AND gate.&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/img/s2pc_tab1.png&#34; &gt;
&lt;img src=&#34;/img/s2pc_tab1.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;


&lt;p&gt;There are 4 possibilities in the truth table but only one is the actual reality. Next, we “garble” this circuit as follows: For each wire $x, y$ and z, we specify two random values corresponding to 0 and 1 and then we encrypt (using some symmetric cipher such as AES) the truth table by encrypting the output-wire key with the corresponding pair of input-wire keys. Which results in the Garbled Computation Table (GCT).&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/img/s2pc_tab2.png&#34; &gt;
&lt;img src=&#34;/img/s2pc_tab2.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;


&lt;p&gt;Given two input keys only one row of the GCT can be decrypted correctly. Next, we rearrange the GCT — so that no information is leaked — and send it to &lt;em&gt;Lalla Salma&lt;/em&gt; along with my input key. Note that, since the key is random, there is no way to associate it with the actual bit. At this point, she has the GCT and my input key but needs the key I have already associated to her input bit. But just like me, &lt;em&gt;Lalla Salma&lt;/em&gt; doesn’t want to reveal her secret (bit)! Neither want I to send her both keys, as she would be able to decrypt more than a GCT row. What we need here is a protocol in which a sender transfers one of potentially many pieces of information to a receiver, but remains oblivious as to what piece has been transferred. Fortunately, such a protocol exists and is called &lt;a href=&#34;https://en.wikipedia.org/wiki/Oblivious_transfer&#34; target=&#34;_blank&#34;&gt;1-out-of-2 oblivious transfer (OT)&lt;/a&gt;. In the next section, I will present a simple 1–2 OT protocol but if you don’t know how RSA encryption works just skip this section since explaining it goes beyond the scope of this post.&lt;/p&gt;

&lt;h2 id=&#34;1-2-oblivious-transfer&#34;&gt;1–2 Oblivious Transfer&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Alice holds $m_0, m_1$, and an RSA key pair $(e, d, N)$. Bob holds the public key $(e, N)$ of Alice, $x \in {0,1}$ and wants $m_x$&lt;/li&gt;
&lt;li&gt;Alice generates random $x_0, x_1$ and sends them to Bob&lt;/li&gt;
&lt;li&gt;Bob chooses a random $k$, computes $v=y_x+k^e$ and sends $v$ to Alice.&lt;/li&gt;
&lt;li&gt;Alice computes $k_0=(v-x_0)^d$ and $k_1=(v-x_1)^d$, and sends $m_0&amp;rsquo;=m_0+k_0$ and $m_1&amp;rsquo;=m_1+k_1$ to Bob&lt;/li&gt;
&lt;li&gt;Bob computes $m_x=m_x&amp;rsquo;-k$ and learns nothing about $m&amp;rsquo; _{1-x}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, using 1–2 OT protocol, &lt;em&gt;Lalla Salma&lt;/em&gt; can have her input key without me knowing anything about her secret bit. At this point, we can decrypt the GCT row corresponding to our secrets and reveal securely the output value. If it is a 0, none is able to tell who rejected the other and if it is a 1… Jackpot!&lt;/p&gt;

&lt;p&gt;By and large, this is how we can do secure two-party computation. So, dear &lt;em&gt;Lalla Salma&lt;/em&gt;, if by any chance you’re reading my post, here is my secret key ;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0x3361736861206c6d616c69696969696b
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Why elliptic curves are called &#34;elliptic&#34; ?</title>
      <link>/post/ellipse/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      <guid>/post/ellipse/</guid>
      <description>&lt;p&gt;Every name tells a story. If you ask new parents &amp;ldquo;how did you choose your baby’s name?&amp;rdquo; sometimes the response will be a vague &amp;ldquo;Oh &lt;em&gt;she&lt;/em&gt; chose!&amp;rdquo; but most of the time there is a story behind, and it’s often a great story about going through dozens of possibilities until one clicked. It goes from &lt;em&gt;her&lt;/em&gt; favorite fictional character to &lt;em&gt;her&lt;/em&gt; favorite great-aunt, so the baby has to be called &lt;a href=&#34;https://en.wikipedia.org/wiki/Daenerys_Targaryen&#34; target=&#34;_blank&#34;&gt;Khaleesi&lt;/a&gt;. Obviously.
In mathematics, it is no different. When mathematicians introduce their new baby to the world, they choose an appropriate name far from being random. In my last &lt;a href=&#34;https://yelhousni.github.io/post/why_ec/&#34; target=&#34;_blank&#34;&gt;post&lt;/a&gt;, I have talked about elliptic curves and why they are used in cryptography. This triggered the question on why they are called &amp;ldquo;elliptic&amp;rdquo; even though they do not resemble ellipses in any way.&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/img/ec_vs_ellipse.png&#34; &gt;
&lt;img src=&#34;/img/ec_vs_ellipse.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;


&lt;p&gt;Elliptic curves are of cubic equations $y^2=x^3+ax+b$ while ellipses are of quadratic equations $x^2/a^2+y^2/b^2=1$. So, prima facie, there is no connection between them. But looking deeply into the history of elliptic curves, one finds out the connection.
In the 18th century it was natural to ask about the arc length of an ellipse. In fact, despite their similarity to circles, ellipses are quite different. For example, a circle’s circumference is given by $2 \pi r$ and its area by $\pi r^2$ where $r$ is the radius. It is remarkable how the constant $\pi$ relates the circumference to the area given the radius $r$. But things are not that easy when dealing with ellipses. Given $a$ and $b$ as the semi-radii, the area of an ellipse is $\pi ab$ but the circumference is a more difficult question. More generally, the arc length of ellipses is difficult to calculate and is given either by a hard integral or by a rather formidable series. This question led to the study of $\sqrt{f(x)}$ where $f(x)$ is a polynomial of degree 3 or 4. These functions cannot be described with familiar calculus functions and came to be known as elliptic integrals. For circles, $f(x)$ is a quadratic polynomial and we get &amp;ldquo;circular integrals&amp;rdquo; which are easy to handle. for example, we know that $\int dx / (\sqrt{1-x^2}) = \sin ^{-1} (x)$ and the inverse of the function, namely $\sin{x}$, is well studied and easy to deal with. Thus, circular integrals lead to the periodic trigonometric functions. Similarly, studying the inverse of elliptic integrals leads to some doubly periodic functions which came to be known as elliptic functions (let’s call them ℘(z) in the sequel, because ℘ looks nice). Furthermore, all the derivatives are doubly periodic with the same periods and satisfy a cubic differential equation. Now in calculus, you learn about parametric equations and how they can describe a curve. By a parameterization of a curve $C$, we mean a continuous bijection from a set of numbers to the set of all points on $C$. For example, letting $x=a \sin{t}$ and $y=b \cos{t}$ with $t \in [0, 2 \pi)$ gives a familiar parameterization of the standard ellipse $x^2/a^2+y^2/b^2=1$. In the same way, we see that setting $x=℘(z)$ and $y=℘’(z)$ gives a parameterization of the cubic curve known today as an elliptic curve.
Names are reservoirs of stories and this was the story behind elliptic curves’ name.&lt;/p&gt;

&lt;p&gt;One last thing before I forget, dear future son, if this post lives long enough so that you are reading it now, I am sure you will understand why I called you Jon Snow. But for now, you know nothing Jon Snow.&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/img/jon_snow.jpg&#34; &gt;
&lt;img src=&#34;/img/jon_snow.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

</description>
    </item>
    
    <item>
      <title>Why do we use elliptic curves for cryptography?</title>
      <link>/post/why_ec/</link>
      <pubDate>Sun, 07 Oct 2018 00:00:00 +0000</pubDate>
      <guid>/post/why_ec/</guid>
      <description>&lt;p&gt;In the series of posts I am willing to write, I will try to answer technical questions I have been asking myself throughout my readings about Maths, cryptography and Blockchain. For many questions, I couldn’t find easily or completely the answer I was looking for. One of these questions I faced is: Why did we even consider using elliptic curves for cryptography ? The question is &amp;ldquo;Why&amp;rdquo; rather than &amp;ldquo;How&amp;rdquo;.
Elliptic curves are mathematical objects from the algebraic geometry and one should be normally surprised when discovering that such objects are used to encrypt data. In fact, elliptic curves are non-singular algebraic curves satisfying an equation of the form $y^3=x^3+ax+b$ (cf. figure 1).&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/img/ec.png&#34; data-caption=&#34;Figure 1: Examples of elliptic curves over $\mathbb{R}^2$&#34;&gt;
&lt;img src=&#34;/img/ec.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Figure 1: Examples of elliptic curves over $\mathbb{R}^2$
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;p&gt;Well, that doesn’t help us a lot.. And since I started this post with a question you have the right to ask more questions: What do these mathy words mean? How did we get this equation? And why are they even called &amp;ldquo;elliptic&amp;rdquo; even though they do not resemble &amp;ldquo;ellipses&amp;rdquo; in any way ? Don’t worry I’ve asked myself these same questions and we’re going to deep dive into the answers in later posts. For now, let’s go back to the main question: Why do we use these curves to encrypt data?
To answer this we have to trace the evolution of cryptography over the years. The earliest known cryptographic schemes use a symmetric approach — that is using the same key for both encryption and decryption. A simple example of this approach and one of the oldest would be &lt;a href=&#34;https://en.wikipedia.org/wiki/Caesar_cipher&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;Caesar cipher&amp;rdquo;&lt;/a&gt; in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. In this scheme the encryption/decryption key is the fixed number of positions that must be kept secret and known only to the communicating parties. This symmetric approach is still widely used today through many ciphers such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&#34; target=&#34;_blank&#34;&gt;AES&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Blowfish_(cipher)&#34; target=&#34;_blank&#34;&gt;Blowfish&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/RC4&#34; target=&#34;_blank&#34;&gt;RC4&lt;/a&gt; but the requirement of a secret symmetric key is still the main drawback.
Cryptographers have been then looking for innovative asymmetric approaches where the decryption key differs from the encryption one. That is said, they have been looking for algorithms where it is easy to derive the decryption key (public) given the encryption key (private) and difficult the other way around — or mathematically put, a function that is straightforward to compute and computationally hard to inverse. One of the first algorithms proposed and still widely used nowadays is the famous &lt;a href=&#34;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&#34; target=&#34;_blank&#34;&gt;RSA&lt;/a&gt; which relies on the hardness of the &amp;ldquo;factorization problem&amp;rdquo;. In fact, given two prime integers, it is easy to compute their multiplication but presumably hard to find the prime integers given the multiplication output. At this point you may (should) be asking why is it hard to factorize an integer and the answer is that there is no published algorithm that can do this in polynomial time (an algorithm is said to be of polynomial time if its running time is upper bounded by a polynomial expression in the size of the input for the algorithm). In fact, the best published asymptotic running time (on a classical computer, not a quantum one. Wait, quantum?) is for the general number field sieve (&lt;a href=&#34;https://en.wikipedia.org/wiki/General_number_field_sieve&#34; target=&#34;_blank&#34;&gt;GNFS&lt;/a&gt;) algorithm which has a sub-exponential complexity. In short, integer factorization is &amp;ldquo;hard&amp;rdquo; in the sense of computational efficiency because &lt;a href=&#34;https://en.wikipedia.org/wiki/P_versus_NP_problem&#34; target=&#34;_blank&#34;&gt;we haven’t found just yet a reason for it to be easy, and we can’t prove it is hard&lt;/a&gt;. All this to come to the point that integer factorization, in my opinion, has nothing to do with the unknown primes distribution as widely believed. It is true that the problem is built upon the &lt;a href=&#34;https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic&#34; target=&#34;_blank&#34;&gt;fundamental theorem of arithmetic&lt;/a&gt; which states that every integer can be uniquely represented as the product of prime numbers but I think that the chaotic nature of primes distribution has no bearing on the problem. There’s no reason to expect that factorization would become even a bit easier by proving the &lt;a href=&#34;https://en.wikipedia.org/wiki/Goldbach%27s_conjecture&#34; target=&#34;_blank&#34;&gt;Goldbach conjecture&lt;/a&gt;, the &lt;a href=&#34;https://en.wikipedia.org/wiki/Twin_prime&#34; target=&#34;_blank&#34;&gt;twin primes conjecture&lt;/a&gt; or the &lt;a href=&#34;https://en.wikipedia.org/wiki/Riemann_hypothesis&#34; target=&#34;_blank&#34;&gt;Riemann Hypothesis&lt;/a&gt; for examples. However, the problem becomes computationally easier (polynomial time) when using quantum computers to run &lt;a href=&#34;https://en.wikipedia.org/wiki/Shor%27s_algorithm&#34; target=&#34;_blank&#34;&gt;Shor’s algorithm&lt;/a&gt; as we will see on a later post.
Another proposed asymmetric construction relies on the hardness of the &amp;ldquo;discrete logarithm&amp;rdquo; problem in cyclic groups. Given integers a and b in a carefully chosen group G, no efficient method is known for recovering the integer k such that $a=b^k$. In fact, the problem is quickly computable in a few special cases but in some cases there is not only no efficient algorithm known for the worst case, but the &lt;a href=&#34;https://en.wikipedia.org/wiki/Average-case_complexity&#34; target=&#34;_blank&#34;&gt;average-case complexity&lt;/a&gt; can be shown to be about as hard as the worst case using &lt;a href=&#34;https://en.wikipedia.org/wiki/Random_self-reducibility&#34; target=&#34;_blank&#34;&gt;random self-reducibility&lt;/a&gt;. So choosing the group G is critical and a popular choice that provides good security assumptions is large prime order subgroups of groups $\mathbb{Z}_p$. These groups were used to build several known cryptographic protocols such as &lt;a href=&#34;https://en.wikipedia.org/wiki/ElGamal_encryption&#34; target=&#34;_blank&#34;&gt;ElGamal encrytpion&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange&#34; target=&#34;_blank&#34;&gt;Diffie-Hellman (DH) key exchange&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange&#34; target=&#34;_blank&#34;&gt;Digital Signature Algorithm (DSA)&lt;/a&gt;. However, using these groups requires large key sizes because of the sub-exponential &lt;a href=&#34;https://en.wikipedia.org/wiki/General_number_field_sieve&#34; target=&#34;_blank&#34;&gt;GNFS&lt;/a&gt; algorithm as well. In fact, while computing discrete logarithms and factoring integers are distinct problems, both are special cases of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Hidden_subgroup_problem&#34; target=&#34;_blank&#34;&gt;hidden subgroup problem&lt;/a&gt; for finite Abelian groups and thus, for both, the most efficient approach remains &lt;a href=&#34;https://en.wikipedia.org/wiki/General_number_field_sieve&#34; target=&#34;_blank&#34;&gt;GNFS&lt;/a&gt; on a classical computer and &lt;a href=&#34;https://en.wikipedia.org/wiki/Shor%27s_algorithm&#34; target=&#34;_blank&#34;&gt;Shor’s algorithm&lt;/a&gt; on a quantum computer.
At this point, you may be thinking that somehow changing that group G from finite fields to elliptic curves may provide better security assumptions. You’re right! The best published algorithms to find discrete logarithms over elliptic curves are &lt;a href=&#34;https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm&#34; target=&#34;_blank&#34;&gt;Pollard’s $\rho$&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Baby-step_giant-step&#34; target=&#34;_blank&#34;&gt;baby-step-giant-step&lt;/a&gt; with a way better running time than &lt;a href=&#34;https://en.wikipedia.org/wiki/General_number_field_sieve&#34; target=&#34;_blank&#34;&gt;GNFS&lt;/a&gt;. But wait, what is a discrete logarithm over elliptic curves? (you ask a lot of questions, huh?) Well, no worries, we will soon deep dive into all the machinery ;)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
