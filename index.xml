<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Homepage</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>Homepage</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 07 Oct 2018 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Homepage</title>
      <link>/</link>
    </image>
    
    <item>
      <title>Why do we use elliptic curves for cryptography?</title>
      <link>/post/why_ec/</link>
      <pubDate>Sun, 07 Oct 2018 00:00:00 +0000</pubDate>
      <guid>/post/why_ec/</guid>
      <description>&lt;p&gt;In the series of posts I am willing to write, I will try to answer technical questions I have been asking myself throughout my readings about Maths, cryptography and Blockchain. For many questions, I couldn’t find easily or completely the answer I was looking for. One of these questions I faced is: Why did we even consider using elliptic curves for cryptography ? The question is &amp;ldquo;Why&amp;rdquo; rather than &amp;ldquo;How&amp;rdquo;.
Elliptic curves are mathematical objects from the algebraic geometry and one should be normally surprised when discovering that such objects are used to encrypt data. In fact, elliptic curves are non-singular algebraic curves satisfying an equation of the form $y^3=x^3+ax+b$ (cf. figure 1).&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/img/ec.png&#34; data-caption=&#34;Figure 1: Examples of elliptic curves over $\mathbb{R}^2$&#34;&gt;
&lt;img src=&#34;/img/ec.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Figure 1: Examples of elliptic curves over $\mathbb{R}^2$
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;p&gt;Well, that doesn’t help us a lot.. And since I started this post with a question you have the right to ask more questions: What do these mathy words mean? How did we get this equation? And why are they even called &amp;ldquo;elliptic&amp;rdquo; even though they do not resemble &amp;ldquo;ellipses&amp;rdquo; in any way ? Don’t worry I’ve asked myself these same questions and we’re going to deep dive into the answers in later posts. For now, let’s go back to the main question: Why do we use these curves to encrypt data?
To answer this we have to trace the evolution of cryptography over the years. The earliest known cryptographic schemes use a symmetric approach — that is using the same key for both encryption and decryption. A simple example of this approach and one of the oldest would be &lt;a href=&#34;https://en.wikipedia.org/wiki/Caesar_cipher&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;Caesar cipher&amp;rdquo;&lt;/a&gt; in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. In this scheme the encryption/decryption key is the fixed number of positions that must be kept secret and known only to the communicating parties. This symmetric approach is still widely used today through many ciphers such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&#34; target=&#34;_blank&#34;&gt;AES&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Blowfish_(cipher)&#34; target=&#34;_blank&#34;&gt;Blowfish&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/RC4&#34; target=&#34;_blank&#34;&gt;RC4&lt;/a&gt; but the requirement of a secret symmetric key is still the main drawback.
Cryptographers have been then looking for innovative asymmetric approaches where the decryption key differs from the encryption one. That is said, they have been looking for algorithms where it is easy to derive the decryption key (public) given the encryption key (private) and difficult the other way around — or mathematically put, a function that is straightforward to compute and computationally hard to inverse. One of the first algorithms proposed and still widely used nowadays is the famous &lt;a href=&#34;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&#34; target=&#34;_blank&#34;&gt;RSA&lt;/a&gt; which relies on the hardness of the &amp;ldquo;factorization problem&amp;rdquo;. In fact, given two prime integers, it is easy to compute their multiplication but presumably hard to find the prime integers given the multiplication output. At this point you may (should) be asking why is it hard to factorize an integer and the answer is that there is no published algorithm that can do this in polynomial time (an algorithm is said to be of polynomial time if its running time is upper bounded by a polynomial expression in the size of the input for the algorithm). In fact, the best published asymptotic running time (on a classical computer, not a quantum one. Wait, quantum?) is for the general number field sieve (&lt;a href=&#34;https://en.wikipedia.org/wiki/General_number_field_sieve&#34; target=&#34;_blank&#34;&gt;GNFS&lt;/a&gt;) algorithm which has a sub-exponential complexity. In short, integer factorization is &amp;ldquo;hard&amp;rdquo; in the sense of computational efficiency because &lt;a href=&#34;https://en.wikipedia.org/wiki/P_versus_NP_problem&#34; target=&#34;_blank&#34;&gt;we haven’t found just yet a reason for it to be easy, and we can’t prove it is hard&lt;/a&gt;. All this to come to the point that integer factorization, in my opinion, has nothing to do with the unknown primes distribution as widely believed. It is true that the problem is built upon the &lt;a href=&#34;https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic&#34; target=&#34;_blank&#34;&gt;fundamental theorem of arithmetic&lt;/a&gt; which states that every integer can be uniquely represented as the product of prime numbers but I think that the chaotic nature of primes distribution has no bearing on the problem. There’s no reason to expect that factorization would become even a bit easier by proving the &lt;a href=&#34;https://en.wikipedia.org/wiki/Goldbach%27s_conjecture&#34; target=&#34;_blank&#34;&gt;Goldbach conjecture&lt;/a&gt;, the &lt;a href=&#34;https://en.wikipedia.org/wiki/Twin_prime&#34; target=&#34;_blank&#34;&gt;twin primes conjecture&lt;/a&gt; or the &lt;a href=&#34;https://en.wikipedia.org/wiki/Riemann_hypothesis&#34; target=&#34;_blank&#34;&gt;Riemann Hypothesis&lt;/a&gt; for examples. However, the problem becomes computationally easier (polynomial time) when using quantum computers to run &lt;a href=&#34;https://en.wikipedia.org/wiki/Shor%27s_algorithm&#34; target=&#34;_blank&#34;&gt;Shor’s algorithm&lt;/a&gt; as we will see on a later post.
Another proposed asymmetric construction relies on the hardness of the &amp;ldquo;discrete logarithm&amp;rdquo; problem in cyclic groups. Given integers a and b in a carefully chosen group G, no efficient method is known for recovering the integer k such that $a=b^k$. In fact, the problem is quickly computable in a few special cases but in some cases there is not only no efficient algorithm known for the worst case, but the &lt;a href=&#34;https://en.wikipedia.org/wiki/Average-case_complexity&#34; target=&#34;_blank&#34;&gt;average-case complexity&lt;/a&gt; can be shown to be about as hard as the worst case using &lt;a href=&#34;https://en.wikipedia.org/wiki/Random_self-reducibility&#34; target=&#34;_blank&#34;&gt;random self-reducibility&lt;/a&gt;. So choosing the group G is critical and a popular choice that provides good security assumptions is large prime order subgroups of groups $\mathbb{Z}_p$. These groups were used to build several known cryptographic protocols such as &lt;a href=&#34;https://en.wikipedia.org/wiki/ElGamal_encryption&#34; target=&#34;_blank&#34;&gt;ElGamal encrytpion&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange&#34; target=&#34;_blank&#34;&gt;Diffie-Hellman (DH) key exchange&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange&#34; target=&#34;_blank&#34;&gt;Digital Signature Algorithm (DSA)&lt;/a&gt;. However, using these groups requires large key sizes because of the sub-exponential &lt;a href=&#34;https://en.wikipedia.org/wiki/General_number_field_sieve&#34; target=&#34;_blank&#34;&gt;GNFS&lt;/a&gt; algorithm as well. In fact, while computing discrete logarithms and factoring integers are distinct problems, both are special cases of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Hidden_subgroup_problem&#34; target=&#34;_blank&#34;&gt;hidden subgroup problem&lt;/a&gt; for finite Abelian groups and thus, for both, the most efficient approach remains &lt;a href=&#34;https://en.wikipedia.org/wiki/General_number_field_sieve&#34; target=&#34;_blank&#34;&gt;GNFS&lt;/a&gt; on a classical computer and &lt;a href=&#34;https://en.wikipedia.org/wiki/Shor%27s_algorithm&#34; target=&#34;_blank&#34;&gt;Shor’s algorithm&lt;/a&gt; on a quantum computer.
At this point, you may be thinking that somehow changing that group G from finite fields to elliptic curves may provide better security assumptions. You’re right! The best published algorithms to find discrete logarithms over elliptic curves are &lt;a href=&#34;https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm&#34; target=&#34;_blank&#34;&gt;Pollard’s $\rho$&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Baby-step_giant-step&#34; target=&#34;_blank&#34;&gt;baby-step-giant-step&lt;/a&gt; with a way better running time than &lt;a href=&#34;https://en.wikipedia.org/wiki/General_number_field_sieve&#34; target=&#34;_blank&#34;&gt;GNFS&lt;/a&gt;. But wait, what is a discrete logarithm over elliptic curves? (you ask a lot of questions, huh?) Well, no worries, we will soon deep dive into all the machinery ;)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
