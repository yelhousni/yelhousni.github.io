[{"authors":["admin"],"categories":null,"content":"I am a cryptographer at Consensys developping a zero-knowledge cryptography open-source ecosystem in Go language (see gnark and gnark-crypto libraries) and building Linea on top of it, an EVM-equivalent Type-2 zkEVM. I completed my PhD in Mathematics and Computer Science at Ecole Polytechnique. I was advised by François Morain and Daniel Augot, and then by Aurore Guillevic.\nMy research focus on efficient proof systems based on algorithmic number theory. I am particularly interested in the theory and application of bilinear pairings and elliptic curves in SNARKs.\n","date":1752883200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1752883200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"2025-07-19T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am a cryptographer at Consensys developping a zero-knowledge cryptography open-source ecosystem in Go language (see gnark and gnark-crypto libraries) and building Linea on top of it, an EVM-equivalent Type-2 zkEVM. I completed my PhD in Mathematics and Computer Science at Ecole Polytechnique. I was advised by François Morain and Daniel Augot, and then by Aurore Guillevic.\nMy research focus on efficient proof systems based on algorithmic number theory. I am particularly interested in the theory and application of bilinear pairings and elliptic curves in SNARKs.\n","tags":null,"title":"Youssef El Housni","type":"authors"},{"authors":null,"categories":null,"content":"The paper \u0026ldquo;Subgroup membership testing on elliptic curves via the Tate pairing\u0026rdquo; by Dmitrii Koshelev (https://eprint.iacr.org/2022/037.pdf) is a cute result. Let $E/F_p$ be an elliptic curve of order $N = c\\cdot r$, with prime integer $r$. To check that a point $P \\in E$ is of order $r$, the naive method is to check that $[r]P = \\mathcal{O}$. The paper shows that, given the group structure $E \\cong Z_{e_1} \\bigoplus Z_{e_2 \\cdot r}$ and $e_2 \\mid p-1$ ($c$ being $e_1\\cdot e_2$), it is sufficient to check that the Tate pairings:\n$$ f_{e_1,P_1}(P)^{(p-1)/e_1} = 1 \\quad \\text{and}\\quad f_{e_2,P_2}(P)^{(p-1)/e_2} = 1 $$\nwhere $P_1$ and $P_2$ are points on $E$ of orders $e_1$ and $e_2$ respectively.\n$E$ is not necessarily pairing-friendly. Pairing-friendliness just means that the embedding degree $k$ is small enough to have fast arithmetic and big enough to have good security (e.g. $k=12$ for BLS12 and BN curves). Here $k=1$ and we only care about performance. To compute these pairings, we need to compute:\nthe Miller functions $f_{e_i,P_i}$ the final exponentiations by $(p-1)/e_i$ The whole idea of the paper is that when $e_i$ are small, these two steps become very efficient to implement.\nStep 2 Let us start with step 2. Given $f\\in F_p$, checking that $f^{(p-1)/e_i} =_? 1$ is equivalent to checking if $f$ is an $e_i$-th residue in $F_p$, i.e. $\\exists z \\in F_p$ s.t. $z^{e_i} = f \\pmod p$. This is known as Euler criterion. For small $e_i$, this can be performed more efficiently than exponentiation, by using Euclidean algorithms. The power residue symbol satisfy similar relations to the GCD and hence one can adapt GCD algorithms to compute power residue symbols. For $e_i = 2$, this is known as the Legendre symbol and can be computed efficiently using the binary GCD algorithm (see Pornin\u0026rsquo;s algorithm and gnark-crypto implementation by Arya). For bigger $e_i \\leq 16$, there are similar algorithms — although less \u0026ldquo;CPU-friendly\u0026rdquo; than the binary-GCD. However, one can always resolve to exponentiations.\nStep 1 Computing Miller functions is done through Miller loops. For small $e_i$, we can explicitly give the formulas. For example when $e_i=2$, the paper states that $f_{e_i,P_i} = X - X_{P_i}$ which is true when the curve is given in short Weierstrass form $E_{sw}: Y^2=X^3+AX+B$. When $e_i=1$, $f_i=1$ trivially. When $e_i=2^m$, the paper gives the formula in page 5.\nDiscussion I believe that the result is significantly performant only when $e_1=e_2=2$, in which case we can compute the Legendre symbol efficiently using the binary-GCD algorithm. For other cases it is still moderately fast using exponentiations, or someone has to implement efficient Euclidean-type higher power residue symbols.\nNow let us focus on the case $e_1=e_2=2$. This happens for the curve Bandersnatch used in Verkle trie. It is mostly efficient when given in twisted Edwards form $E_{ed}: ax^2+y^2=1+dx^2y^2$. So to implement this test with input points $(x,y)\\in E_{ed}$, we need to map $(x,y)$ to $(X,Y) \\in E_{sw}$. The formula is:\n$$ X = (\\frac{a-d}{4})\\cdot(\\frac{1+y}{1-y}) + \\frac{a+d}{6} $$\nand we don\u0026rsquo;t need the $Y$ coordinate.\nTo avoid inverses we use the fact that $(\\frac{1/x}{p})2 = (\\frac{x}{p})2$. Thus, $f{2,P_i} = X - X{P_i}$ becomes:\n$$ 12(a-d)^2(1-y)[(5a - d - 12X_{P_i}) + (a - 5d + 12X_{P_i})y] $$\nor equivalently\n$$ t_2 (1-y)(t_1 + t_0y) $$\nwith $t_2=12(a-d)^2$, $t_1=5a - d - 12X_{P_i}$ and $t_0=a - 5d + 12X_{P_i}$ some pre-computed constants.\nFor Bandersnatch implementers, they just need to take this last formula with:\n$X_{P_1} = \\texttt{0x23e93c143a3aa62dfef158aabe40ed250530ac9369509c984891a87e04178ed3}$ $X_{P_2} = \\texttt{0x5de00fbdcf0964d2188e44aec311d927af0f7e94e94fca97c891a87d84178ed1}$ which leads, for the first point, to:\n$t_0=1$ $t_1=1$ $t_2=\\texttt{0x384d1c153c878eea316b96e5c340cf6abd025b636bd74122926c66eb6fa86d15}$ and, for the second, to:\n$t_0=\\texttt{0x636b1e56f54c03e873dd6068f2f238776f43b4a3d72a357835d2fc15ba90cdea}$ $t_1=\\texttt{0x108288fc3451795fbf5c779f16af9f8de479ef5f28d42686ca2d03e9456f321d}$ $t_2=\\texttt{0x34f9acec8bf92f766108eca94020963ae3496e2743876768b74534c34ef9473e}$ A full implementation in gnark-crypto can be found here: https://github.com/Consensys/gnark-crypto/pull/708\n","date":1759708800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759708800,"objectID":"89f82a738371cdc2a8600cf4d7f2e5b8","permalink":"/post/subgroup/","publishdate":"2025-10-06T00:00:00Z","relpermalink":"/post/subgroup/","section":"post","summary":"From my Hackmd - hackmd.io/@yelhousni","tags":null,"title":"A note on implementing subgroup membership using the Tate pairing","type":"post"},{"authors":null,"categories":null,"content":"Proof systems of arbitrary computations have found many applications in recent years. However, the proving algorithm has a consequent complexity tied to the size of the computation being proved. Thus, proving large computations is quite inefficient. One of these large computations is the scalar multiplication over an elliptic curve. In this work, we provide new techniques for reducing the time corresponding to proving a scalar multiplication, using integer lattice reduction or a (half) extended Euclidean algorithm in a ring of integers. We investigate optimizations in the case of small (complex multiplication) discriminant curves, and its generalization for multi scalar multiplications as used in signature verification. We provide an optimized Golang implementation for different elliptic curves in different proof systems settings. The speed-up in proving time is between 22% and 53% compared to the previous state-of-the-art.\n","date":1759276800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759276800,"objectID":"890f97aefafefacbf28892192932b98a","permalink":"/talk/latincrypt25/","publishdate":"2025-10-01T00:00:00Z","relpermalink":"/talk/latincrypt25/","section":"talk","summary":"Latincrypt 2025 - Medellin, Colombia","tags":null,"title":"Fast Elliptic Curve Scalar Multiplications in SN(T)ARK Circuits","type":"talk"},{"authors":null,"categories":null,"content":"This talk was about implementing bilinear pairings, with focus on gnark-crypto optimizations. It covers the mathematical foundations of pairings, their applications in cryptography, and practical considerations for efficient implementation. The talk also discusses challenges faced during the implementation process and how they were addressed, providing insights into the complexities of working with advanced cryptographic primitives.\n","date":1753315200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1753315200,"objectID":"c0abef334ce1f73104262f041fee5020","permalink":"/talk/google25/","publishdate":"2025-07-24T00:00:00Z","relpermalink":"/talk/google25/","section":"talk","summary":"Google Seminar - NYC, United States","tags":null,"title":"On pairing implementation","type":"talk"},{"authors":["Youssef El Housni","Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1752883200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1752883200,"objectID":"fd51d1cd3f585e523af7eb036a1d34ad","permalink":"/publication/preprint/preprint25-1311/","publishdate":"2025-07-19T00:00:00Z","relpermalink":"/publication/preprint/preprint25-1311/","section":"publication","summary":"PRE-PRINT 2025 ([ePrint 2025/1311](https://ia.cr/2025/1311))","tags":null,"title":"Batch subgroup membership testing on pairing-friendly curves","type":"publication"},{"authors":["Youssef El Housni","Youssef El Housni","Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1747958400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1747958400,"objectID":"ef1bca511be90820f8b3ec65c8e66c91","permalink":"/publication/conference/latincrypt25/","publishdate":"2025-05-23T00:00:00Z","relpermalink":"/publication/conference/latincrypt25/","section":"publication","summary":"LATINCRYPT 2025 ([ePrint 2025/933](https://ia.cr/2025/933))","tags":null,"title":"Fast elliptic curve scalar multiplications in SN(T)ARK circuits","type":"publication"},{"authors":null,"categories":null,"content":"In this presentation, we will explore the fascinating intersection of zero-knowledge proofs and blockchain technology. We will begin by demystifying zero-knowledge proofs, explaining their fundamental principles and tracing their evolution from theoretical primitives to practical tools in cryptography. Following this, we will delve into the world of blockchain, discussing its reliance on cryptographic techniques to ensure security and integrity. The core of the talk will focus on the necessity of zero-knowledge proofs in blockchain applications, addressing privacy and scalability concerns. We will highlight how blockchain technology has spurred significant advancements in zero-knowledge proof research, fostering collaboration between academia and industry. Finally, I will present my own contributions to the field, including the optimization of mathematical building blocks for zero-knowledge proofs and their concrete applications within blockchain systems. This presentation aims to provide a comprehensive understanding of the critical role zero-knowledge proofs play in enhancing blockchain technology and to share insights from cutting-edge research in this dynamic area.\n","date":1745452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1745452800,"objectID":"ec073eaf5b6071ee86ae0f668b914e51","permalink":"/talk/um6p_benguerir/","publishdate":"2025-04-24T00:00:00Z","relpermalink":"/talk/um6p_benguerir/","section":"talk","summary":"University Mohammed VI Polytechnic - Ben Guerir, Morocco","tags":null,"title":"Zero-knowedge proofs and blockchains","type":"talk"},{"authors":null,"categories":null,"content":"I helped organize the Cipher Challenge 2025 — Cryptography Edtion held at the University Mohammed VI Polytechnique (UM6P) in Rabat, Morocco. The event took place on April 12 and 13, 2025, and was a great success, attracting participants from various universities and institutions in Morocco.\nMy contribution was twofold: Prior to the event, I created (most of) the challenges and also assisted in grading the students. On April the 12th, I gave a keynote talk on Modern \u0026ldquo;Applications of Cryptography\u0026rdquo;. The material I contributed can be found at: https://cipherchallenge.github.io/.\n","date":1744416000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1744416000,"objectID":"f064f46b29df6f27229f53f1ffe12eb3","permalink":"/post/cipherchallenge/","publishdate":"2025-04-12T00:00:00Z","relpermalink":"/post/cipherchallenge/","section":"post","summary":"Organization of the Cipher Challenge at UM6P","tags":null,"title":"Cipher Challenge 2025 — UM6P","type":"post"},{"authors":null,"categories":null,"content":"I helped organize the Cipher Challenge at UM6P College of Computing, a competition that brings together students from all over Morocco. The material I contributed can be found at: https://cipherchallenge.github.io/. I gave a keynote presentation that delves into the fascinating world of cryptography and its evolution from classical techniques to modern applications. This talk provides a comprehensive overview of how cryptography has been traditionally used for encryption and digital signatures, and then explores groundbreaking advancements that are shaping the future of secure communication and data protection. Throughout the talk, we provide concrete examples of how these cryptographic techniques are being utilized in popular platforms and technologies, including Playstation, TikTok, Apple, WhatsApp, and various blockchains such as Bitcoin and Ethereum. By the end of the session, the goal is for the attendees to have a deeper appreciation for the critical role cryptography plays in our digital world and the innovative ways it continues to evolve to meet new challenges.\n","date":1744416000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1744416000,"objectID":"f143490a79d65fb4b642fdd39e36d6fd","permalink":"/talk/um6p_cipherchallenge/","publishdate":"2025-04-12T00:00:00Z","relpermalink":"/talk/um6p_cipherchallenge/","section":"talk","summary":"University Mohammed VI Polytechnic - Rabat, Morocco","tags":null,"title":"Modern Applications of Cryptography","type":"talk"},{"authors":null,"categories":null,"content":"Elliptic curves are used in many proof systems. Some systems (e.g. Bulletproofs) use plain curves (e.g. ed25519). Some (e.g. Groth16, KZG-PLONK) use pairing-friendly curves (e.g. BLS12-381). Some recursive systems require pairing-friendly 2-cycle (e.g. MNT4/6) or 2-chains (e.g. BLS12-377/BW6-761). Some other recursive/folding systems require plain 2-cycle (e.g. Pasta). In this talk we will go through the difference between these curves and why there isn\u0026rsquo;t a silver bullet curve for all scenarios.\n","date":1731369600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1731369600,"objectID":"de4e72e71943417b02c226cc3d95bfe4","permalink":"/talk/devcon7/","publishdate":"2024-11-12T00:00:00Z","relpermalink":"/talk/devcon7/","section":"talk","summary":"Devcon 7 - Bangkok, Thailand","tags":null,"title":"Elliptic curves and SNARKs — Past, present and future.","type":"talk"},{"authors":null,"categories":null,"content":"We show a way to implement GLV-like scalar multiplication in SNARK circuits in the absence of an efficient endomorphism. When this latter is available, we show how to turn proving a scalar multiplication into proving a 4 dimensional multi-scalar multiplication of small scalars.\n","date":1731283200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1731283200,"objectID":"bd2567fdacfa8530a98cc5a041530e8b","permalink":"/talk/zkhub/","publishdate":"2024-11-11T00:00:00Z","relpermalink":"/talk/zkhub/","section":"talk","summary":"ZK Hub - Bangkok, Thailand","tags":null,"title":"On proving scalar multiplications in SNARKs","type":"talk"},{"authors":null,"categories":null,"content":" _____ _ ____ _ __ __ | ___|_ _| | _____ / ___| |\\ \\ / / | |_ / _` | |/ / _ \\ | | _| | \\ \\ / / | _| (_| | \u0026lt; __/ | |_| | |__\\ V / |_| \\__,_|_|\\_\\___| \\____|_____\\_/ You don\u0026rsquo;t need an efficient endomorphism to implement GLV-like scalar multiplication in SNARK circuits Introduction Other applications Background The fake GLV trick Implementation Benchmark Comparison Introduction P-256, also known as secp256r1 and prime256v1, is a 256-bit prime field Weierstrass curve standardized by the NIST. It is widely adopted in internet systems, which explains its myriad use cases in platforms such as TLS, DNSSEC, Apple’s Secure Enclave, Passkeys, Android Keystore, and Yubikey. The key operation in elliptic curves based cryptography is the scalar multiplication. When the curve is equipped with an efficient endomorphism it is possible to speed up this operation through the well-known GLV algorithm. P-256 does unfortunately not have an efficient endomorphism (see parameters) to enjoy this speedup.\nVerifying ECDSA signatures on Ethereum through precompiled contracts, i.e. smart contracts built into the Ethereum protocol (there are only 9) is only possible with the secp256k1 curve and not the P-256. Verifying ECDSA signatures on P-256 requires computing scalar multiplications in Solidity and is especially useful for smart-contract wallets, enabling hardware-based signing keys and safer, easier self-custody. Different solutions can bring P-256 signatures on-chain. There are primarily three interesting approaches: (zk)-SNARK based verifiers, smart contract verifiers (e.g. [Dubois23], Ledger/FCL (deprecated), smoo.th/SCL and daimo/p256verifier), and native protocol precompiles (EIP/RIP 7212).\nUsing SNARK (succinctness) properties, provides a great way to reduce gas cost for computation on Ethereum (e.g. ~232k gas for Groth16, ~285k gas for PLONK and ~185k gas for FFLONK). This is very competitive with (and sometimes better that) the currently gas-optimal smart contract verifier. Moreover one can batch many ECDSA verifications in a single proof, amortizing thus the gas cost. However verifying P-256 signatures in a SNARK circuit can be very expensive i.e. long proving time. This is because the field where the points on the P-256 curve lie is different than the field where the SNARK computation is usually expressed. To be able to verify the proof onchain through the procompile the SNARK field needs to be the BN254 scalar field. Different teams tried to implement the ECDSA verification on P-256 in a BN254 SNARK circuit efficiently. Among these: zkwebauthn/webauthn-halo2, https://github.com/zkwebauthn/webauthn-circom and PSE/circom-ecdsa-p256.\nIf P-256 had an efficient endomorphism we could have optimized the proving time a great deal!\nIn this note we show a way to implement a GLV-like scalar multiplications in-circuit without having an efficient endomorphism.\nOther applications This technique can be applied to any elliptic curve without an efficient endomorphism (e.g. Curve25519, P-384, MNT-753 (k=4, k=6), STARK curve, $\\mathcal{B}$ of \u0026ldquo;cycle5\u0026rdquo;, \u0026hellip;). See this database for other curves. This would question the choice of Bandersnatch (an embedded endomorphism-equipped curve over BLS12-381) over Jubjub (an embedded curve over BLS12-381 without endomorphism) for Ethereum Verkle trees. This can speedup ECDSA verification in Starknet and Cairo (through the STARK curve). This can speedup natively the folding step (à la Nova) of Ed25519 signatures through the 2-cycles proposed here by Aurore Guillevic. Background Standard scalar multiplication Let $E$ be an elliptic curve defined over the prime field $\\mathbb{F}_p$ and let $r$ be a prime divisor of the curve order #$E(\\mathbb{F}_p)$ (i.e. the number of points). Let $s \\in \\mathbb{F}_r$ and $P(x,y) \\in E(\\mathbb{F}_p)$, we are interested in proving scalar multiplication $s\\cdot P$ over the $r$-torsion subgroup of $E$, denoted $E[r]$ (i.e. the subset of points of order $r$).\nThe simplest algorithm is the standard left-to-right double-and-add:\nINPUT: s = (s_{t−1},..., s_1, s_0), P ∈ E(Fp). OUTPUT: sP. 1. Q ← ∞. 2. For i from t−1 downto 0 do 2.1 Q ← 2Q. 2.2 If s_i = 1 then Q ← Q + P. 3. Return(Q). If/else branching is not possible in SNARK circuits so this is replaced by constant window table lookups inside the circuit. This can be achieved using polynomials which vanish at the constants that aren’t being selected, i.e. a 1-bit table lookup Q ← s_i * Q + (1 - s_i) * (Q+P). Hence this double-and-add algorithm requires $t$ doublings, $t$ additions and $t$ 1-bit table lookup. This can be extended to windowed double-and-add, i.e. scanning more than a bit per iteration using larger window tables, but the multiplicative depth of the evaluation increases exponentially. We use affine coordinates for doubling/adding points because inverses cost as much as multiplications, i.e. instead of checking that $1/x$ is $y$ we provide $y$ out-circuit and check in-circuit that $x\\cdot y = 1$. However since we start with $Q ← ∞$ it is infeasible to avoid conditional branching since affine formulas are incomplete. Instead, we scan the bits right-to-left and assume that the first bit s_0 is 1 (so that we start at Q ← P), we double the input point P instead of the accumulator Q in this algorithm and finally conditionally subtract (using the 1-bit lookup) P if s_0 was 0.\nINPUT: s = (s_{t−1},..., s_1, s_0), P ∈ E(Fp). OUTPUT: sP. 1. Q ← P. 2. For i from 1 to t−1 do 2.1 If s_i = 1 then Q ← Q + P. 2.2 P ← 2P. 3. if s_0 = 0 then Q ← Q - P 4. Return(Q). GLV scalar multiplication However it is well known that if the curve is equipped with an efficient endomorphism then there exists a faster algorithm known as [GLV]. :::info Example 1 : suppose that $E$ has Complex Multiplication (CM) with discrimant $-D=-3$, i.e. $E$ is of the form $y^2=x^3+b$, with $b \\in \\mathbb{F}_p$. This is the case of BN254, BLS12-381 and secp256k1 elliptic curves used in Ethereum. There is an efficient endomorphism $\\phi: E \\rightarrow E$ defined by $(x,y)\\mapsto (\\omega x,y)$ (and $\\mathcal{O} \\mapsto \\mathcal{O}$) that acts on $P \\in E[r]$ as $\\phi(P)=\\lambda \\cdot P$. Both $\\omega$ and $\\lambda$ are cube roots of unity in $\\mathbb{F}_p$ and $\\mathbb{F}_r$ respectively, i.e. $\\omega^2+\\omega+1 \\equiv 0 \\pmod p$ and $\\lambda^2+\\lambda+1 \\equiv 0 \\pmod r$. ::: :::info Example 2 : suppose that $E$ has Complex Multiplication (CM) with discrimant $-D=-8$, meaning that the endomorphism ring is $\\mathbf{Z}[\\sqrt{−2}]$. This is the case of the Bandersnatch elliptic curves specified in Ethereum Verkle trie. There is an efficient endomorphism $\\phi: E \\rightarrow E$ whose kernel is generated by a 2-torsion point. The map can be found by looking at 2-isogeneous curves and applying Vélu\u0026rsquo;s formulas. For Bandersnatch it is defined by $(x,y)\\mapsto (u^2\\cdot \\frac{x^2+wx+t}{x+w},u^3\\cdot y\\cdot \\frac{x^2+2wx+v}{(x+w)^2})$ for some constants $u,v,w,t$ (and $\\mathcal{O} \\mapsto \\mathcal{O}$) that acts on $P \\in E[r]$ as $\\phi(P)=\\lambda \\cdot P$ where $\\lambda^2+2 \\equiv 0 \\pmod r$. ::: The GLV algorithm starts by decomposing $s$ as $s = s_0 + \\lambda s_1$ and then replacing the scalar multiplication $s \\cdot P$ by $s_0 \\cdot P + s_1 \\cdot \\phi(P)$. Because $s_0$ and $s_1$ are guaranteed to be $\\leq \\sqrt{r}$ (see Sec.4 of [GLV] and Sec.4 of [FourQ] for an optimization trick), we can halve the size of the for loop in the double-and-add algorithm. We can then scan simultaenously the bits of $s_0$ and $s_1$ and apply the Strauss-Shamir trick. This results in a significant speed up but only when an endomorphism is available. For example the left-to-right double-and-add would become:\nINPUT: s and P ∈ E(Fp). OUTPUT: sP. 1. Find s1 and s2 s.t. s = s1 + 𝜆 * s2 mod r 1.1 let s1 = (s1_{t−1},..., s1_1, s1_0) 1.2 and s2 = = (s2_{t−1},..., s2_1, s2_0) 2. P1 ← P, P2 ← 𝜙(P) and Q ← ∞. 3. For i from t−1 downto 0 do 3.1 Q ← 2Q. 3.2 If s1_i = 0 and s2_i = 0 then Q ← Q. 3.3 If s1_i = 1 and s2_i = 0 then Q ← Q + P1. 3.4 If s1_i = 0 and s2_i = 1 then Q ← Q + P2. 3.5 If s1_i = 1 and s2_i = 1 then Q ← Q + P1 + P2. 4. Return(Q). Using the efficient endomorphism in-circuit is also possible (see [Halo, Sec. 6.2 and Appendix C] or [gnark implementation] for short Weierstrass curves and [arkworks] and [gnark] implementations for twisted Edwards). But one should be careful about some extra checks of the decomposition $s = s_0 + \\lambda s_1 \\mod r$ (not the SNARK modulus). The integers $s_0, s_1$ can possibly be negative in which case they will be reduced in-circuit modulo the SNARK field and not $r$.\nThe fake GLV trick Remember that we are proving that $s\\cdot P = Q$ and not computing it. We can \u0026ldquo;hint\u0026rdquo; the result $Q$ and check in-circuit that $s\\cdot P - Q = \\mathcal{O}$. Now, if we can find $u,v \\leq \\sqrt{r}$ such that $v\\cdot s = u \\pmod r$ then we can check instead that $$ (v\\cdot s)\\cdot P - v\\cdot Q = \\mathcal{O}$$ which is equivalent to $$ u\\cdot P - v\\cdot Q = \\mathcal{O}$$ The thing now is that $u$ and $v$ are \u0026ldquo;small\u0026rdquo; and we can, similarly to the GLV algorithm, halve the size of the double-and-add loop and apply the Strauss-Shamir trick.\nSolution: running the half-GCD algorithm (i.e. running GCD half-way) is sufficient to find $u$ and $v$. We can apply the exact same trick for finding the lattice basis as in the GLV paper (Sec. 4). For completeness we recall the algorithm hereafter. We apply the extended Euclidean algorithm to find the greatest common divisor of $r$ and $s$ (This gcd is 1 since $r$ is prime.) The algorithm produces a sequence of equations $$w_i \\cdot r + v_i \\cdot s = u_i$$ for $i = 0, 1, 2, \\dots$ where $w_0 = 1, v_0 = 0, u_0 = r, w_1 = 0, v_1 = 1, u_1 = s$, and $u_i \\geq 0$ for all $i$. We stop at the index $m$ for which $u_m \\geq \\sqrt{r}$ and take $u = u_{m+1}$ and $v = -v_{m+1}$. Note: By construction $u$ is guaranteed to be a positive integer but $v$ can be negative, in which case it would be reduced in-circuit modulo the SNARK modulus and not $r$. To circumvent this we return in the hint $u$, $v$ and a $\\texttt{b}=1$ if $v$ is negative and $\\texttt{b}=0$ otherwise. In-circuit we negate $Q$ instead when $\\texttt{b}=1$.\nImplementation A generic implementation in the gnark library is available at gnark.io (feat/fake-GLV branch). For Short Weierstrass (e.g. P256) look at the scalarMulFakeGLV method in the emulated package and for twisted Edwards (e.g. Bandersnatch/Jubjub) look at the scalarMulFakeGLV method in the native package.\nBenchmark The best algorithm to implement scalar multiplication in a non-native circuit (i.e. circuit field ≠ curve field) when an efficient endomorphism is not available is an adaptation of [Joye07] (implemented in gnark here). Next we compare this scalar multiplication with our fake GLV in a PLONKish vanilla (i.e. no custom gates) circuit (scs) over the BN254 curve (Ethereum compatible). We also give benchmarks in R1CS.\nP-256 Old (Joye07) New (fake GLV) $[s]P$ 738,031 scs / 186,466 r1cs 385,412 scs / 100,914 r1cs ECDSA verification 1,135,876 scs / 293,814 r1cs 742,541 scs / 195,266 r1cs Note here that the old ECDSA verification uses Strauss-Shamir trick for computing $[s]P+[t]Q$ while the new version is merely two fake GLV multiplications and an addition.\nComparison p256wallet.org is an ERC-4337 smart contract wallet that leverages zk-SNARKs for WebAuthn and P-256 signature verification. It uses PSE/circom-ecdsa-p256 to generate the webAuthn proof, and underneath PSE/circom-ecdsa-p256 to generate the ECDSA proof on P-256 curve. The github README reports 1,972,905 R1CS. Compiling our circuit in R1CS results in 195,266 R1CS. This is more than a 10x reduction, which is not only due to the fake GLV algorithm but also to optimized non-native field arithmetic in gnark.\nOther curves Similar results are noticed for other curves in short Weirstrass, e.g. P-384 and STARK curve:\nP-384 Old (Joye07) New (fake GLV) $[s]P$ 1,438,071 scs 782,674 scs ECDSA verification 2,174,027 scs 1,419,929 scs STARK curve Old (Joye07) New (fake GLV) $[s]P$ 727,033 scs 380,210 scs ECDSA verification 1,137,459 scs 732,131 scs and also in twisted Edwards e.g. Jubjub vs. Bandersnatch:\nJubjub Old (2-bit double-and-add) New (fake GLV) $[s]P$ 5,863 scs / 3,314 r1cs 4,549 scs / 2,401 r1cs Bandersnatch Old (GLV) New (fake GLV) $[s]P$ 4,781 scs / 2,455 r1cs 4,712 scs / 2,420 r1cs EDIT: Thanks to Ben Smith for reporting that a similar idea was proposed in [SAC05:ABGL+] for ECDSA verification. We note that, in our context, the trick applies to a single scalar multiplication and that the half GCD is free through the hint.\n","date":1726790400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1726790400,"objectID":"f712a7d5b4252d165fb9979bbfb67549","permalink":"/post/fakeglv/","publishdate":"2024-09-20T00:00:00Z","relpermalink":"/post/fakeglv/","section":"post","summary":"From my Hackmd - hackmd.io/@yelhousni","tags":null,"title":"Fake GLV","type":"post"},{"authors":null,"categories":null,"content":"This presentation is about the proof aggregation protocol in the Linea zkEVM. It uses the elliptic 2-chain of curves BLS12-377 and BW6-761 to aggregate PLONK-KZG proofs and reduce the verification cost.\n","date":1717286400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1717286400,"objectID":"0f7a65af39c3a9034ab471886c71a7dc","permalink":"/talk/zkbelgrade/","publishdate":"2024-06-02T00:00:00Z","relpermalink":"/talk/zkbelgrade/","section":"talk","summary":"zkBelgrade - Belgrade, Serbia","tags":null,"title":"zkAggregation in Linea","type":"talk"},{"authors":null,"categories":null,"content":"In this podcast episode, Antonio Sanso (EF researcher) and myself discuss with Anna Rose (host) and Nico (co-host from Geometry research) our new work, Families of prime-order endomorphism-equipped embedded curves on pairing-friendly curves and dive into Elliptic Curve cryptography, Bandersnatch and Verkle Tries amongst much more, before dissecting what terms in the title of this paper truly mean. After getting into the weeds of cryptographic technicalities, the group explores where this work could be used and what it would enable.\n","date":1715731200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1715731200,"objectID":"6e5f9311a0e70bff7347d5595a734cbd","permalink":"/talk/zkpodcast24/","publishdate":"2024-05-15T00:00:00Z","relpermalink":"/talk/zkpodcast24/","section":"talk","summary":"zkPodcast Episode 324 (Antonio Sanso and myself)","tags":null,"title":"Discovering New Elliptic Curves (podcast)","type":"talk"},{"authors":null,"categories":null,"content":"This presentation is about the gnark and gnark-crypto libraries and how they are used to aggregate proofs on the Linea zkEVM.\n","date":1711670400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1711670400,"objectID":"31b2ad672553241c7f765590840e9bf2","permalink":"/talk/proofdaynyc/","publishdate":"2024-03-29T00:00:00Z","relpermalink":"/talk/proofdaynyc/","section":"talk","summary":"Proof Day NYC Edition - NYC, USA","tags":null,"title":"gnark and 2-chain aggregation for Linea","type":"talk"},{"authors":["Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1696896000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1696896000,"objectID":"201f28e28222ca1c37253d60c2b93ee8","permalink":"/publication/journal/joc24/","publishdate":"2023-10-10T00:00:00Z","relpermalink":"/publication/journal/joc24/","section":"publication","summary":"Journal of Cryptology 2024 ([ePrint 2023/1662](https://ia.cr/2023/1662))","tags":null,"title":"Families of prime-order endomorphism-equipped embedded curves on pairing-friendly curves","type":"publication"},{"authors":null,"categories":null,"content":"This presentation is about the conference article that can be found online here. The bottleneck in the proving algorithm of most of elliptic-curve-based SNARK proof systems is the Multi-Scalar-Multiplication (MSM) algorithm. In this paper we give an overview of a variant of the Pippenger MSM algorithm together with a set of optimizations tailored for curves that admit a twisted Edwards form. We prove that this is the case for SNARK-friendly chains and cycles of elliptic curves, which are useful for recursive constructions. Our contribution is twofold: first, we optimize the arithmetic of finite fields by improving on the well-known Coarsely Integrated Operand Scanning (CIOS) modular multiplication. This is a contribution of independent interest that applies to many different contexts. Second, we propose a new coordinate system for twisted Edwards curves tailored for the Pippenger MSM algorithm.Accelerating the MSM over these curves is critical for deployment of recursive proof systems applications such as proof-carrying-data, blockchain rollups and blockchain light clients. We implement our work in Go and benchmark it on two different CPU architectures (x86 and arm64). We show that our implementation achieves a 40-47% speedup over the state-of-the-art implementation (which was implemented in Rust). This MSM implementation won the first place in the ZPrize competition in the open division “Accelerating MSM on Mobile” and will be deployed in two real-world applications: Linea zkEVM by Consensys and probably Celo network.\n","date":1694390400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1694390400,"objectID":"a2dedb5ebaa9c651cbc85e2248c408e0","permalink":"/talk/ches23/","publishdate":"2023-09-11T00:00:00Z","relpermalink":"/talk/ches23/","section":"talk","summary":"CHES 2023 - Prague, Czech Republic","tags":null,"title":"Faster Montgomery multiplication and Multi-Scalar-Multiplication for SNARKs","type":"talk"},{"authors":null,"categories":null,"content":"This presentation is about the conference article that can be found online here. In this work, we consider efficiently implementing pairings in Rank-1 Constraint Systems (R1CS), a widely used model to express SNARK statements. We show that our techniques almost halve the arithmetic circuit depth of the previously best known pairing implementation on a Barreto\u0026ndash;Lynn\u0026ndash;Scott (BLS) curve of embedding degree 12, resulting in 70% faster proving time. We also investigate and implement the case of BLS curves of embedding degree 24.\n","date":1689120000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1689120000,"objectID":"0ca5aef41337110a75d2ac9ef9e7acfe","permalink":"/talk/siam-ag23/","publishdate":"2023-07-12T00:00:00Z","relpermalink":"/talk/siam-ag23/","section":"talk","summary":"SIAM-AG23 - Eindhoven, Netherlands","tags":null,"title":"Pairings in Rank-1 Constraint System","type":"talk"},{"authors":null,"categories":null,"content":"This presentation is about the conference article that can be found online here. In this work, we consider efficiently implementing pairings in Rank-1 Constraint Systems (R1CS), a widely used model to express SNARK statements. We show that our techniques almost halve the arithmetic circuit depth of the previously best known pairing implementation on a Barreto\u0026ndash;Lynn\u0026ndash;Scott (BLS) curve of embedding degree 12, resulting in 70% faster proving time. We also investigate and implement the case of BLS curves of embedding degree 24.\n","date":1687219200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1687219200,"objectID":"8e9686e11fed4dd512eea8b2e1ab4cb5","permalink":"/talk/acns23/","publishdate":"2023-06-20T00:00:00Z","relpermalink":"/talk/acns23/","section":"talk","summary":"ACNS 2023 - Kyoto, Japan","tags":null,"title":"Pairings in Rank-1 Constraint System","type":"talk"},{"authors":null,"categories":null,"content":" Zero-knowledge cryptography is a groundbreaking new technology enabling privacy, interoperability, and scalability for Web 3.0 protocols and applications. Like the DARPA Grand Challenge, select teams will compete for monetary prizes spanning a range of categories. Over $7M in prize money has been committed, along with token grants from sponsoring projects.\nAll winning submissions will become open-source libraries for the benefit of all. We hope this foundation can support the next generation of decentralized protocols and applications to enable secure, interoperable, and scalable applications for the next-generation web.\nWith Gautam Botrel from Consensys, we participated in the inaugural edition of ZPrize (2022) in the open division: \u0026ldquo;ACCELERATING MSM ON MOBILE\u0026rdquo; as the gnark team. Our submission resulted in a 4.2x speedup over the baseline and won the first place. The prize was $259,147.\nACCELERATING MSM ON MOBILE Proving on mobile devices is a transformative technology for applications including private transactions, self-sovereign identity, and scalable computation. Multi-scalar multiplication (MSM) is a core operation for producing zkSNARKs, and it is the primary bottleneck and barrier for deployment of proving on mobile. This prize will focus on minimizing latency of computing MSM in native mobile applications.\nThe goal was to write the fastest MSM over BLS12-377 curve on a mobile device (Samsung Galaxy A13 5G). The specification details can be found here.\nOur submission was written in Go, and derived from the gnark-crypto project. On the target device, for a random BLS12-377 G1 MSM ($n = 2^{16}$), we measured:\n~2309ms for the reference benchmark ~509ms for our submission This is a -77.9% optimisation.\nCode and techniques The code can be found on github here under Apache-2 or MIT license.\nWe experimented several approaches; here is a description of the key findings for the final ones:\nIt uses our in-house gnark-crypto/bls12377 package, which out of the box performs very well compared to the zprize baseline. The MSM algorithm is described in this paper (to appear in TCHES, Issue 3) and the Go code is documented. We introduced a bls12-377 algorithmic optimization; the \u0026ldquo;bucket/pippenger\u0026rdquo; method now uses an optimized twisted edwards extended cordinate system, resulting in a significant performance improvement (~30% on some target). We perform a static build targetting a 64bit arm linux architecture, which allows without a complicated build procress to run 64bit code on the target device. We copy the output in the armv7 (32bit) destination folder; in a production deployment, Java calling code must at runtime check for the actual CPU architecture and switch to a fallback if it\u0026rsquo;s 32bit (outside of the scope of the challenge). Note that while the submission spawn a process at each msm call, other ways may turn out more efficient (allocate the verifying key on the stack, communicate with the process with unix sockets, \u0026hellip;). We hand tuned the field arithmetic for the Multiplication targetting the arm64 architecture. Our pure-go version performed better than the arm assembly one, and resulted in a ~20% speed up on some platforms compared to existing version in gnark-crypto. We implemented and optimized a dedicated Squaring algorithm (rather than calling the Multiplication as in gnark-crypto) following our previous work https://hackmd.io/@gnark/modular_multiplication (also described in the TCHES paper), which resulted in significant perf improvement on the target device. This is not used in the twisted edwards extended MSM, only in the parameterized Jacobian version which uses Affine points as input (branch: buckets/jacobian, performance: ~600ms for $2^16$). For the target (arm64) we add ~40lines of arm assembly for a small function (fp.Butterfly(a, b) -\u0026gt; a = a + b; b = a - b). The perf impact is ~5%, as it speeds up a bit the UnifiedMixedAdd point addition in the buckets (msm). The rest of the submission is compiled from pure Go code; On this device, our GPU experimentations were not promising. We raised an issue to the Golang team. Once the fix is merged into the latest Golang compiler release, we might squeeze an extra 5-10% perf improvement. Results The results were annouced on 04-04-2023 in this blog post. The main sponsor (Ocelot) authored a more detailed announcement for the specific Mobile division in this post. ","date":1680566400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680566400,"objectID":"17082be129ad037f1ee9b1ad8d69ca63","permalink":"/post/zprize/","publishdate":"2023-04-04T00:00:00Z","relpermalink":"/post/zprize/","section":"post","summary":"1st place winner of the Mobile category","tags":null,"title":"ZPrize competition 2022","type":"post"},{"authors":["Youssef El Housni"],"categories":null,"content":"","date":1668729600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1668729600,"objectID":"8657893a95694767ca015aa679ae1e07","permalink":"/publication/preprint/phd/","publishdate":"2022-11-18T00:00:00Z","relpermalink":"/publication/preprint/phd/","section":"publication","summary":"PhD dissertation","tags":null,"title":"The arithmetic of pairing-based proof systems","type":"publication"},{"authors":null,"categories":null,"content":"This is my PhD defense.\n","date":1668729600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1668729600,"objectID":"9e5c51f4c691f4f2399c69a2950df877","permalink":"/talk/phd/","publishdate":"2022-11-18T00:00:00Z","relpermalink":"/talk/phd/","section":"talk","summary":"PhD defense - Palaiseau, France","tags":null,"title":"The arithmetic of pairing-based proof systems","type":"talk"},{"authors":["Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1666483200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1666483200,"objectID":"8e5183620685eab74e2a96dc51fef737","permalink":"/publication/journal/tches23/","publishdate":"2022-10-23T00:00:00Z","relpermalink":"/publication/journal/tches23/","section":"publication","summary":"TCHES 2023, Issue 3 ([ePrint 2022/1400](https://ia.cr/2022/1400))","tags":null,"title":"Faster Montgomery multiplication and Multi-Scalar-Multiplication for SNARKs","type":"publication"},{"authors":null,"categories":null,"content":"This talk is about algorithmic optimizations techniques used in gnark. In particular, we show that the implementation of Multi-Scalar-Multiplication (MSM) is 45% faster compared to competitors libraries. We also explain optimizations in the pairing computations both out-circuit and in-circuit. To the best of our knowledge, these implementations are best-in-class.\n","date":1665619200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1665619200,"objectID":"7f4dcd194669e9c30b24e64b2e1f82ee","permalink":"/talk/devcon6/","publishdate":"2022-10-13T00:00:00Z","relpermalink":"/talk/devcon6/","section":"talk","summary":"Devcon 6 - Bogota, Colombia","tags":null,"title":"Optimizing cryptographic algorithms in gnark","type":"talk"},{"authors":null,"categories":null,"content":"A proof system is a protocol where one party (called the prover) tries to convince another party (called the verifier) that a given statement is true. In the class of non-interactive proof systems, a particularly interesting concept for proving the computational integrity is the Succinct Non-interactive ARgument of Knowledge (SNARK). It provides a computationally sound proof, cheap to verify and small compared to the size of the statement or the witness. Bilinear pairings over elliptic curves have become key ingredients for instantiating such SNARKs. In this thesis we investigate tailored pairing-friendly elliptic curves to efficiently implement SNARKs. We present a study at three stages of the process: curves to instantiate a SNARK, curves to instantiate a recursive SNARK, and also curves to express an elliptic-curve related statement. We provide new constructions of curves for SNARKs and new families of 2-chain curves for recursive SNARKs. We derive and implement in open-source efficient algorithms to speed up the arithmetic on these curves: Co-factor clearing, subgroup membership testing, multi-scalar multiplication and pairings over 2-chains. We also study and optimize elliptic curves arithmetic and pairings as a SNARK statement, yielding to the fastest recursive proof generation in pairing-based settings.\n","date":1663286400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663286400,"objectID":"8055ba8501255bb0786d910f9ef114b5","permalink":"/talk/rennes_seminar/","publishdate":"2022-09-16T00:00:00Z","relpermalink":"/talk/rennes_seminar/","section":"talk","summary":"Rennes Crypto Seminar - Rennes, France","tags":null,"title":"Elliptic curves and zk-SNARKs","type":"talk"},{"authors":null,"categories":null,"content":"An important cryptographic operation on elliptic curves is hashing to a point on the curve. When the curve is not of prime order, the point is multiplied by the cofactor so that the result has a prime order. This is important to avoid small subgroup attacks for example. A second important operation, in the composite-order case, is testing whether a point belongs to the subgroup of prime order. A pairing is a bilinear map e: G1×G2 → GT where G1 and G2 are distinct subgroups of prime order r of an elliptic curve, and GT is a multiplicative subgroup of the same prime order r of a finite field extension. Pairing-friendly curves are rarely of prime order. In this talk, we investigate cofactor clearing and subgroup membership testing on these composite-order curves. First, we generalize a result on faster cofactor clearing for BLS curves to other pairingfriendly families of a polynomial form from the taxonomy of Freeman, Scott and Teske. Second, we investigate subgroup membership testing for G1 and G2. We fix a proof argument for the G2 case that appeared in a preprint by Scott in late 2021 and has recently been implemented in different cryptographic libraries. We then generalize the result to both G1 and G2 and apply it to different pairing-friendly families of curves. This gives a simple and shared framework to prove membership tests for both cryptographic subgroups.\n","date":1658275200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658275200,"objectID":"83640dff3b5fc96f50cbcda6229b0f58","permalink":"/talk/africacrypt22/","publishdate":"2022-07-20T00:00:00Z","relpermalink":"/talk/africacrypt22/","section":"talk","summary":"Africacrypt 2022 - Fez, Morocco","tags":null,"title":"Cofactor clearing and subgroup membership testing on pairing-friendly elliptic curves","type":"talk"},{"authors":["Youssef El Housni"],"categories":null,"content":"","date":1654646400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1654646400,"objectID":"9e32b512d676e22942e41945fc44d8ac","permalink":"/publication/conference/acns23/","publishdate":"2022-06-08T00:00:00Z","relpermalink":"/publication/conference/acns23/","section":"publication","summary":"ACNS 2023 ([ePrint 2022/1162](https://ia.cr/2022/1162))","tags":null,"title":"Pairings in Rank-1 Constraint System","type":"publication"},{"authors":null,"categories":null,"content":"In this talk, we first are interested in families of 2-chains in which the BW6-761 curve would fall. We present a family of BW6 curves from any BLS12 curve and derive generic formulas, in terms of the BLS12 curve seed u, and integer parameters ht,hy. We extend this work to a 2-chain family of BW6 curves from BLS24 curves. To achieve higher levels of security in the target finite field of the outer curves, we compare a larger field characteristic thanks to larger parameters ht,hy, to the larger embedding degrees 8 and 12 obtained with Cocks-Pinch curves. Finally, we argue that the BLS12 and BLS24 based families are respectively tailored for Groth’16 and KZG-based SNARKs recursive proof composition, and we present a short list of curves with an optimized implementation along with benchmarks.\n","date":1654041600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1654041600,"objectID":"689be8dcb08403ba5953786360d40660","permalink":"/talk/eurocrypt22/","publishdate":"2022-06-01T00:00:00Z","relpermalink":"/talk/eurocrypt22/","section":"talk","summary":"Eurocrypt 2022 - Trondheim, Norway","tags":null,"title":"Families of SNARK-friendly 2-chains of elliptic curves","type":"talk"},{"authors":["Youssef El Housni","Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1652313600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652313600,"objectID":"4eeb5799e83e24ea86478c92f72f102d","permalink":"/publication/journal/dcc22/","publishdate":"2022-05-12T00:00:00Z","relpermalink":"/publication/journal/dcc22/","section":"publication","summary":"DCC 2022 ([ePrint 2022/586](https://ia.cr/2022/586))","tags":null,"title":"A survey of elliptic curves for proof systems","type":"publication"},{"authors":null,"categories":null,"content":"Elliptic curves have become key ingredients for instantiating zero-knowledge proofs and more generally proof systems. Recently, there have been many tailored constructions of these curves that aim at efficiently implementing different kinds of proof systems. In this talk we provide a comprehensive view on existing work. We present an overview at two stages of the process; curves to instantiate a SNARK and curves to instantiate a recursive SNARK.\n","date":1652227200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652227200,"objectID":"28a7a5bdf6763949db3fb06ea2e631f3","permalink":"/talk/aarhus_seminar/","publishdate":"2022-05-11T00:00:00Z","relpermalink":"/talk/aarhus_seminar/","section":"talk","summary":"Aarhus Crypto Seminar - Aarhus, Denmark","tags":null,"title":"Elliptic curves and SNARKs","type":"talk"},{"authors":["Youssef El Housni","Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1651190400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1651190400,"objectID":"edb6273a533942823e5b723376daa836","permalink":"/publication/conference/africacrypt22/","publishdate":"2022-04-29T00:00:00Z","relpermalink":"/publication/conference/africacrypt22/","section":"publication","summary":"AFRICACRYPT 2022 ([ePrint 2022/352](https://ia.cr/2022/352))","tags":null,"title":"Co-factor clearing and subgroup membership testing on pairing-friendly curves","type":"publication"},{"authors":null,"categories":null,"content":"This presentation is about how to efficiently express a pairing a Rank-1 Constraint System (R1CS) arithmetic circuit. The goal is to reduce the time complexity to SNARK prove a bilinear pairing. A corresponding research paper will be soon available on ePrint.\n","date":1650499200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650499200,"objectID":"6d646a74b29c2aa5a3d1bbc3a62ab0bf","permalink":"/talk/zksummit7/","publishdate":"2022-04-21T00:00:00Z","relpermalink":"/talk/zksummit7/","section":"talk","summary":"zkSummit 7 - Amsterdam, Netherlands","tags":null,"title":"Pairings in R1CS","type":"talk"},{"authors":null,"categories":null,"content":"In this talk, we first are interested in families of 2-chains in which the BW6-761 curve would fall. We present a family of BW6 curves from any BLS12 curve and derive generic formulas, in terms of the BLS12 curve seed u, and integer parameters ht,hy. We extend this work to a 2-chain family of BW6 curves from BLS24 curves. To achieve higher levels of security in the target finite field of the outer curves, we compare a larger field characteristic thanks to larger parameters ht,hy, to the larger embedding degrees 8 and 12 obtained with Cocks-Pinch curves. Finally, we argue that the BLS12 and BLS24 based families are respectively tailored for Groth’16 and KZG-based SNARKs recursive proof composition, and we present a short list of curves with an optimized implementation along with benchmarks.\n","date":1649980800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1649980800,"objectID":"22971cc6885ded3a682a22ef19a6fa66","permalink":"/talk/jc2-2022/","publishdate":"2022-04-15T00:00:00Z","relpermalink":"/talk/jc2-2022/","section":"talk","summary":"Journées Codage et Cryptographie (JC2) - Hendaye, France","tags":null,"title":"Families of SNARK-friendly 2-chains of elliptic curves","type":"talk"},{"authors":["Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1646092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646092800,"objectID":"af662a9b9413e618cad147b36ac16118","permalink":"/publication/conference/eurocrypt22/","publishdate":"2022-03-01T00:00:00Z","relpermalink":"/publication/conference/eurocrypt22/","section":"publication","summary":"EUROCRYPT 2022 ([ePrint 2021/1359](https://ia.cr/2021/1359))","tags":null,"title":"Families of SNARK-friendly 2-chains of elliptic curves","type":"publication"},{"authors":null,"categories":null,"content":"This presentation is about requirements and methods to contruct tailored and optimized elliptic curves for zkSNARK applications.\n","date":1612828800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612828800,"objectID":"dfc0cecd83b4811cddbfa6e409c46923","permalink":"/talk/caramba_seminar/","publishdate":"2021-02-09T00:00:00Z","relpermalink":"/talk/caramba_seminar/","section":"talk","summary":"Caramba seminar - Nancy, France","tags":null,"title":"On choosing suitable elliptic curves for zk-SNARK","type":"talk"},{"authors":null,"categories":null,"content":"This presentation is an introduction to the concept of zkSNARKs alongside an step-by-step toy example of Pinocchio-ish zkSNARK protocol.\n","date":1612483200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1612483200,"objectID":"6d7027046e70a541bf8efc6610c228de","permalink":"/talk/oisillons_gt/","publishdate":"2021-02-05T00:00:00Z","relpermalink":"/talk/oisillons_gt/","section":"talk","summary":"GRACE Young Seminar (GT Oisillons) - Paris, France","tags":null,"title":"zk-SNARK 101","type":"talk"},{"authors":null,"categories":null,"content":"This presentation is about a joint paper with Aurore Guillevic that can be found online here. It proposes new families of elliptic curves that are tailored and optimized for recursive SNARKs.\n","date":1607990400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607990400,"objectID":"67f727cc42a627aeb0cfb8f7f628cf85","permalink":"/talk/cans2020/","publishdate":"2020-12-15T00:00:00Z","relpermalink":"/talk/cans2020/","section":"talk","summary":"CANS2020 - Vienna, Austria","tags":null,"title":"Optimized and secure pairing-friendly elliptic curve suitable for one layer proof composition","type":"talk"},{"authors":null,"categories":null,"content":"This presentation is about using the BW6-761 curve to generate and verify faster composed Groth'16 zk-SNARK proofs and its application in EY Blockchain effort to privacy-preserving blockchains.\n","date":1594166400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594166400,"objectID":"9e12d557de3625afc7cffaf965bccd17","permalink":"/talk/ey_summit/","publishdate":"2020-07-08T00:00:00Z","relpermalink":"/talk/ey_summit/","section":"talk","summary":"EY Blockchain summit - NYC, USA","tags":null,"title":"Faster proof composition with the BW6-761 curve","type":"talk"},{"authors":null,"categories":null,"content":"This presentation is about a joint paper with Aurore Guillevic that can be found online here. It introduced a new elliptic curve, namely BW6-761 that is very efficient for one-layer recursive SNARKs compared to the state-of-the-art.\n","date":1585612800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585612800,"objectID":"ddff58aa9f75a0a0820ba71eaf3e8452","permalink":"/talk/zksummit5/","publishdate":"2020-03-31T00:00:00Z","relpermalink":"/talk/zksummit5/","section":"talk","summary":"zkSummit 5 - Berlin, Germany","tags":null,"title":"Optimized and secure pairing-friendly elliptic curve suitable for one layer proof composition","type":"talk"},{"authors":["Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1585008000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585008000,"objectID":"33bd57240de52083ceebc7a5ad12f680","permalink":"/publication/conference/cans20/","publishdate":"2020-03-24T00:00:00Z","relpermalink":"/publication/conference/cans20/","section":"publication","summary":"CANS 2020 ([ePrint 2020/351](https://ia.cr/2020/351))","tags":null,"title":"Optimized and secure pairing-friendly elliptic curves suitable for one layer proof composition","type":"publication"},{"authors":null,"categories":null,"content":"We believe that public blockchain is the future of business to business transactions. However, two issues - privacy and scalability - will need to be solved if this vision is to be fully realised. This talk will explain the motivations behind the open-source nightfall code and how it is intended to tackle the first of these issues. We cover the operation of the protocol, the method by which it provides complete privacy, and how developers can use it to build their own applications by making use of its smart contract infrastructure and the ZoKrates framework. We will also present our modelling of transaction costs, which shows that nightfall can already provide a cost-competitive alternative to private blockchains for many situations and how that will be true for a growing number of use cases in the near future.\n","date":1570665600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570665600,"objectID":"a4147696e932c879e6d8f402c8ed8619","permalink":"/talk/devcon5/","publishdate":"2019-10-10T00:00:00Z","relpermalink":"/talk/devcon5/","section":"talk","summary":"Devcon 5 - Osaka, Japan","tags":null,"title":"Nightfall - The Open Source Privacy Solution for Ethereum","type":"talk"},{"authors":null,"categories":null,"content":"Once upon a time, the entire Universe was inside a bubble that was thousands of times smaller than a pinhead. It was hotter and denser than anything we can imagine. Then it suddenly exploded. The Universe that we know was born. Time, space and matter all began with the Big Bang. In a fraction of a second, the Universe grew from smaller than a single atom to bigger than a galaxy. And it kept on growing at a fantastic rate. It is still expanding today.\nA biodiversity of species came to life. The total number of all species living on Earth estimates there are about 8.7 million species but the most important specie of all is one that, in the geological time scale, appeared recently. It is the human specie. So much happened on Earth before we came to call it home, but if we only focus on human life there is too much to narrate about.\nOne of the main discoveries by humans was fire control, it was an important step in their culture. It allowed humans to cook food and get warmth and protection. But before that, making fire also allowed destructive use as humans used it to attack predators, insects and each others.\nEveryone knows this story but today I’m going to tell a similar story, as fascinating as this one. It is the story of elliptic curves. I’ll walk you through the pre- big bang and the post- big bang, I’ll show you the biodiversity of elliptic curves species and will present you to the specie used in cryptography, a.k.a. the Homo genus. Finally, we will go through a similar story to fire control that is pairing control.\nI presented this story the 4th of July in Paris during ZK-PAR 0x01, the first Zero Knowledge meetup in the french capital. The meetups started in Tel-Aviv and then London and now Paris. They are intended for anyone interested in applied cryptography for privacy-preserving technology. The presentations are usually focussed on technical and practical aspects of this technology, notably its relation to blockchain technology. You can find more information and community discussions in the Facebook group and the Youtube channel.\nZK-PAR 0x01 hosted two speakers, Bastien Teinturier and myself. Bastien talked about anonymous payments in Bitcoin’s Lightning network and I invite you to watch his video and go through his slides. After that, my presentation was about this story of elliptic curves, or the story of life. Here is the video and the slides.\nThanks to the sponsors of ZK-PAR: Beam, Consensys and Bitcoin.fr\n","date":1565827200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565827200,"objectID":"d85b1f1094772ffb84d43c937419dd47","permalink":"/post/zkpar1/","publishdate":"2019-08-15T00:00:00Z","relpermalink":"/post/zkpar1/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"ZK-PAR 0x01","type":"post"},{"authors":null,"categories":null,"content":"I this presentation the 4th of July in Paris during ZK-PAR 0x01, the first Zero Knowledge meetup in the french capital. The meetups started in Tel-Aviv and then London and now Paris. They are intended for anyone interested in applied cryptography for privacy-preserving technology. The presentations are usually focussed on technical and practical aspects of this technology, notably its relation to blockchain technology. You can find more information and community discussions in the Facebook group and the Youtube channel.\nZK-PAR 0x01 hosted two speakers, Bastien Teinturier and myself. Bastien talked about anonymous payments in Bitcoin’s Lightning network and I invite you to watch his video and go through his slides.\n","date":1562198400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562198400,"objectID":"cdbe0f83cdafaced28cb540a1a0719e3","permalink":"/talk/zk_par1/","publishdate":"2019-07-04T00:00:00Z","relpermalink":"/talk/zk_par1/","section":"talk","summary":"ZK-PAR 0x01 - Paris, France","tags":null,"title":"Elliptic curves in cryptography","type":"talk"},{"authors":null,"categories":null,"content":"ZK Study club is a learning group where people from the zero-knowledge/Blockchain community gather to study a specific topic. There have been so far nine sessions that discussed several cryptographic topics. The first four sessions broke down the ZK-STARKs, the fifth session was a deep dive into RSA accumulators, the sixth was about Sigma protocols, the seventh discussed the Fiat-Shamir heuristic and the eighth was about multi-party computations. The sessions are usually recorded and put available online:\nsession 1: ZK-STARKs seesion 2: ZK-STARKs session 3: ZK-STARKs session 4: ZK-STARKs session 5: RSA accumulators session 6: Sigma protocols session 7: Fiat-Shamir heuristics session 8: Multi-party computations The ninth session happened last Monday 6th May and was the first of a series about the recent paper called “Zexe: Enabling Decentralized Private Computation” by Sean Bowe from ZCash, Alessandro Chiesa, Pratyush Mishra and Howard Wu from UC Berkeley, Matthew Green from Johns Hopkins University and Ian Miers from Cornell Tech. I had the chance to lead this session and discuss the paper’s ideas with wonderful community enthusiasts. The video can be found here and the session’s notes here.\nBasically, the aim behind Zexe is to write private smart contract on a distributed ledger. Such a scheme can be constructed by doing offline computation and uploading a proof of correct execution to the ledger. The proof should be zero-knowledge, succinct and easy to verify. To do this, the paper introduces a new cryptographic primitive called decentralized private computation (DPC) and comes up with some efficient implementation tricks that range from zkSNARK optimization, recursive proof composition and a new set of elliptic curves.\nThe starting point of Zexe is to extend Zerocash protocol to more general token-based blockchains. This protocol provides a privacy-preserving version of Bitcoin-like blockchains via the use of zero-knowledge proofs (ZKP). To create a coin a user publishes a commitment and to consume it he publishes its unique serial number alongside some ZKP that the serial numbers belong to some old coins and that the commitments preserve the same total value. In Zexe, an integer value coin is a data payload record and the ZKP assures that an arbitrary function was applied to old records to create the new ones. The problem now is, if we want the function to be user-defined, how can we make sure it stays private, and if so, how can we isolate “malicious” functions from “honest” functions? One straightforward solution would be to add a ZKP that proves the same function was used; this basically boils down to using a Zerocash per function (i.e. per token) which results in a functionality limitation as one cannot do private cross-token swaps for instance and moreover the anonymity set would be limited to each each specific token history. Another solution would be to use a universal function on the ledger and embed user-defined functions within the data payload. To do this, we need a minimalist shared execution environment (some sort of an operating system) where different processes can be executed without violating the privacy of each. Zexe calls it records nano-kernel where a record is now: data payload, birth predicate for records creation, death predicate for records consumption, transaction memorandum for public input needed by the predicates and auxiliary input for private input. The problem now is, if the predicates are arbitrary functions, do we need a SNARK per predicate or a universal SNARK? While awesome research is being conducted to propose a universal SNARK like Sonic, efficient implementations are yet to come. A solution to the cost of universality would be to do “a proof of a proof”, that is, generating a proof of the predicate and then generating another proof of the previous proof that will be verified on the ledger. This way, we need a single circuit on the ledger and a circuit per predicate offline.\nWhile empirically proved via cycles of elliptic curves, recursive proofs are not efficient at 128-bit security level. In fact, a SNARK proof (i.e. in Groth16) is a set of points on an elliptic curve that has a subgroup of order $n$ so the generation has arithmetic in $\\mathbb{F}_n$ whereas the verification uses p airing computations where most of the computations are on an extension of the field size $p$. This causes an arithmetic mismatch that results in an overhead of $log(p)$ when one wants to implement naïvely a verification circuit. The solution to this is to use a cycle of elliptic curves where the field size of one is equal to the subgroup order of the other and vice-versa. The only pairing-friendly cycle of elliptic curves we know is the set of MNT4 and MNT6 curves that have a low embedding degree and thus are not quite efficient at 128-bit security level. In Zexe scheme, we need merely a proof of a proof so the authors came up with a chain of elliptic curves rather than a cycle, namely a Cocks-pinch curve embedded over a BLS curves that is highly 2-adic with respect to both the field size and the subgroup order.\nThis is somewhat an overview of Zexe, but the paper includes more contributions such as delegating the generation of a proof to an untrusted worker (delegated DPC), minimizing operations over the (heavy) embedded cocks-pinch curve, optimizing the NP statements à la Zcash and more\u0026hellip;\n","date":1557360000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557360000,"objectID":"6404d562697d7db2197250d5ba20ab71","permalink":"/post/zexe/","publishdate":"2019-05-09T00:00:00Z","relpermalink":"/post/zexe/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"ZEXE - Zero-knowledge EXEcution","type":"post"},{"authors":null,"categories":null,"content":" “There are no more Horcruxes. It’s just you and me. Neither can live while the other survives, and one of us is about to leave for good…” —Harry Potter and the Deathly Hallows, Chapter 36: The Flaw in the Plan.\nThe Horcrux hunt was a mission started by Albus Dumbeldore and given to Harry Potter to find all of Lord Voldemort’s remaining Horcruxes and destroy them. Obsessed with immortality from a young age, Lord Voldemort created a series of Horcruxes in an effort to prevent his death. A Horcrux is a vessel into which one places a piece of one’s soul to protect one from mortal death. Voldemort split his soul into 7 secret parts in a way that reconstruction is possible. It is widely believed that the process for Horcrux splitting involves a spell and a horrific act is performed after a murder has been committed, but this is not true. Voldemort invented this cover story to keep secret the very simple spell he used (a wizard patent for the technical term) — it is called the 3S spell.\nThe 3S spell is nothing but a Shamir secret sharing scheme. In this scheme, a dealer (Voldemort) splits a secret (his soul) into multiple shares (Horcruxes) in a way that reconstruction is only possible when combining all of the shares or some sufficient fixed number of them. The spell uses some basic polynomial algebra magic (1st year at Hogwarts) and some finite field wizardry.\nBasic scheme Let’s $s$ be the secret and $n$ the number of shares, a dealer can construct a secret sharing scheme where only $t \u0026lt; n$ custodians can reconstruct the secret $s$. He first generates a $t$-degree polynomial $P(X) = p_0 + p_1X + p_2X^2 + · · · + p_t X^t$ where $p_0$ is the secret $s$ and $p_1, p_2, \\dots , p_t$ are chosen at random from the finite field we’re working in (e.g. $\\mathbb{F}_31$ which means integers from 0 to 30). He then computes the points $v_1 = P(1), v_2 = P(2), \\dots and v_n = P(n)$ and distributes these $n$ shares to the custodians. Any $t \u0026lt; n$ shares can reconstruct the polynomial $P$ with interpolation (e.g. Lagrange interpolation) and recover the original secret $s = P(0)$. Note that any $t − 1$ shares would interpolate with high probability a false polynomial.\nOne can draw an infinite number of polynomials of degree 2 through 2 points. 3 points are required to define a unique polynomial of degree 2. This image is for illustration purposes only — Shamir’s scheme uses polynomials over a finite field, not re-presentable on a 2-dimensional plane (Wikipedia) This is a polynomial curve over a finite field — now the order of the polynomial has seemingly little to do with the shape of the graph (Wikipedia) Verifiable scheme There are two problems with the basic scheme:\nA malicious custodian can submit a false share A malicious dealer can distribute false shares The first issue can be addressed by adding some fingerprint to the secret. This way, if a malicious custodian submit a false share, the reconstructed secret won’t be correct and the fingerprint lost. One way to do this is by concatenating the secret s with the hash of the last 31 bytes of s, i.e. s ← (s||sha256(s[: −32]). However, identifying the malicious custodian remains impossible in this approach.\nThe solution to the second problem, can both identify a malicious dealer and a malicious custodian in the first scenario. A simple approach would be to publicly publish the hashes of shares but this might be impractical in some use-cases where the number of custodians increases quickly. In fact, each custodian will have a database of auxiliary information that may increases quickly over the time. A better approach was proposed by Feldman and uses homomorphic commitments.\nFeldman’s approach: In this approach, the dealer publishes the commitments of polynomial’s coefficients $p_0= s$ and $p_1, p_2, \\dots, p_t$ that are homomorphic with respect to multiplication. Such a commitment is known to be a Pedersen’s commitment. Given a finite field of prime characteristic $p$ and a generator $g$, the dealer publishes $c_0 \\equiv g^s \\pmod p, c_1 \\equiv g^{p_1} \\pmod p, \\dots$ and $c_t \\equiv g^{p_t} \\pmod p$. Given the commitments $c_i$ for $i \\in [0, t]$, the is no way to retrieve the secret $s$ and the coefficients $p_1, p_2, \\dots, p_t$ because of the hardness of the discrete logarithm problem. A custodian can verify that the share $v_i$ he was given by the dealer wasn’t tampered with thanks to the homomorphic property of Pedersen’s commitments. In fact,\nThis is basically the magic 3S spell that allowed Lord Voldemort to split his soul into 7 horcruxes. The process is rather simple that even Ronald Weasley can perform, but Tom Riddle invented the horrific-act-after-murder story to keep away wizardry newbies from reaching immortality.\nYes, I ruined your childhood memories. Sorry Not Sorry.\n","date":1554163200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554163200,"objectID":"3c6e2c8c5bb25a211bd966420d18f105","permalink":"/post/sss/","publishdate":"2019-04-02T00:00:00Z","relpermalink":"/post/sss/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"Shamir Secret Sharing — The magic 3S Spell","type":"post"},{"authors":null,"categories":null,"content":"On March 22nd 2019, I attended the third edition of zero-knowledge summit ZK0x03 held at Berlin. The summit was organized by Anna Rose and Fredrik Harrysson from zero-knowledge podcast, which is made for fellow developers and people looking to educate themselves on the inner workings of the blockchain zero-knowledge tech space. This one-day event focused on zero-knowledge topics, zkSNARK, MPCs, STARKs and blockchain scaling solutions featuring the following speakers:\nAhivu Levy (StarkWare Industries) discussing scalability with STARKs Harry Roberts (Ethsnarks) sharing the history of high-level programming languages for making zk proofs John \u0026lsquo;Tux\u0026rsquo; Pacific (Nucypher) on fully homomorphic encryption Jordi Baylina (Iden3) on Circom and Snarkjs Izaak Meckler (CODA Protocol) on the secrets of SNARK programming Alex Vlasov (Matter Labs) on scaling \u0026amp; privacy with zkSNARKs in Ethereum Aurélien Nicolas (QED-it, zkproofs.org) discussing zk standards Zachary Williamson (Aztec Protocol) on ERC-1724 confidential digital assets Igor Barinov (POA Network) on scaling with xDai and side chains Jonathan Levi (HACERA) on ZKPs for both permissioned and permissionless blockchains There were also discussions on confidential transaction scheme based on 1-out-of-N proofs, GDPR and privacy of Zcash shielded transactions as well as deep-dive workshops on practical use and implementation of ZKPs, building a STARK with pen and paper and more. The program ran from 9:30 a.m. to 8 p.m. where talks were presented at two different filmed stages while roundtables and circle discussion happened on two other dedicated rooms. The full program can be found here and the playlist of videos here.\nSince the program was running in parallel, I couldn’t make it to all the presentations so I chose 3 talks and 2 roundtables I was most interested in:\nTalk 1: scalability first with STARK — Ahivu levy (StarkWare industries) video of the talk This talk was about scalability using STARKs — It was presented by Ahivu, the head product of StarkWare, a startup that leverages on STARK technology to improve blockchain scalability and privacy. The main takeaway is that they are planning to release their first product mid-april which is a decentralized exchange (DEX) engine on Ethereum. While STARKs can solve privacy on the blockchain as it is widely believed, Ahivu thinks that they are the best candidate to solve scalability thanks to the exponentially small verifier running time.\nTalk 2: fully homomorphic encryption the road to secure computation — John Tux Pacific (NuCypher) video of the talk This talk was about secure multiparty computation (SMPC), trusted execution evironments (TEE) and fully homomorphic encryption (FHE) with focus on the latter. It was presented by John who is a cryptography engineer at NuCypher, a startup that works mainly on proxy-reencryption and FHE to build privacy infrastructure for the blockchain. John started by presenting SMPC, TEE and FHE, and and then listed the pros and cons of each approach. Because FHE seems to be the ideal approach, he then exposed how research is aiming to address FHE cons.\nTalk 3: Scaling and privacy with zkSNARKs in Ethereum — Alex Vlasov (Matter Labs) video of the talk Although the title of this talk is “scaling and privacy with zkSNARKs in Etherem”, the presentation was mainly about the new zero-knowledge protocol called SONIC and its comparison to the actual Groth16 zkSNARK protocol implemented in ZCash. The talk was presented by Alex who works at Matter Labs, a startup aiming to scale the blockchain using zero-knowledge proofs. SONIC is a new ZK proving system that requires an updatable and universal trusted setup — that means unlike other SNARKs, SONIC does not require a trusted setup for each circuit, but only a single setup for all circuits (up to a given circuit depth) and it never has to end, so it can be continuously secured by accumulating more contributions. To this point, Alex gave a nice comparison between usual SNARKs and SONIC; imagine you are playing a card game and you want some trusted deck of cards, in SNARKs you shuffle the deck and then you pass it to other players who shuffle it again every time you start a new game, but in SONICs you only shuffle the deck once and then “clone” it every time you start a new game (this works for every game that requires the same number of cards or less ~circuit depth). For efficiency comparison, Groth16 is still better (0.6s vs 9s for a single proof and 3s vs 11.5s for a batch of 5 proofs — according to Alex benchmark) but we still need an efficient SONIC implementation as in Bellman to compare apples to apples. The main takeaway is that SONICs are a real breakthrough that solve somewhat the SNARKs trusted setup issue. It is to mention that I discussed SONICs with Ariel Gabizon (former ZCash cryptographer who discovered the trusted setup counterfeiting bug in ZCash) after the talk and he believes that a lot of research is being conducted in this direction and more efficient protocols are likely to be proposed later this year.\nRoundtable 1: GPU implementation of zksnark prover — Konstantin Panarin (Matter Lab) This roundtable was animated by Konstantin from Matter Labs. He started by describing NVIDIA GPU architecture and code parallelization principles with examples, then he discussed how we can benefit from GPUs to speedup the proving step in Groth16 zkSNARKs. The most important part of the proving step (~60% of the computation time) is the multi-exponentiation and one way to do this efficiently is using Pippenger algorithm (ZCash by the way moved from Bos-Coster algortihm to Pippenger after Sapling activation). We discussed how the algorithm works and how it can be enhanced using NVIDIA GPUs keeping in mind that an enhancement should not only address the computation time but also the memory cost.\nRoundtable 2: Building a STARK with pen and paper — Mathew Stevens and Micro Richter This one was funny actually— we were 30 people at the beginning but only 10 stayed until the very end because of the heavy maths content. We deep dived into all the dirty details of the mathematical machinery behind zkSTARKS given a toy example (a Fibonacci sequence). The steps are:\nArithmetic intermediate representation (AIR) to show a computation as an execution trace with algebraic registers and to create polynomial contraints, algebraic placement and routing (APR) to transform the AIR into functions that are Reed-Solomon codes if and only if the execution trace is a witness, Reed-Solomon proximity testing (RPT) to check that an APR witness is an actual Reed-Solomon code in an efficient way, and fast Reed-Solomon Interactive oracle proof of proximity (FRI) to efficiently check the proximity to the Reed-Solomon codes. The summit was closed by a park bench panel animated by Anna and Fredrik in a game form. Anyone from the audience can ask any question but if it turns out to be an opinion/remark then she/he is invited on stage to answer the upcoming questions. Here is a question I asked (which is actually an opinion according to Mrs Justice Anna): “Zero-knowledge proofs (ZKP) like zkSNARKs or zkSTARKs are not proofs but arguments because the soundness is only computational and not statistical, so is it a mistake to call them proofs?”\nBesides the talks which were really interesting, this event was an opportunity to meet a lot of people from the broad ZKP/Blockchain community and to discuss technical details with sometimes the authors of some papers I’ve been scouring over the few last months. For this reason, I want to thank the organizers Anna and Fredrik for putting all of this together and especially Xavier De Boissieu and Quentin Drouot from EY for making my attendance possible.\n","date":1553299200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553299200,"objectID":"a0d297c6200510b79a624ef44d992c28","permalink":"/post/zk_summit_3/","publishdate":"2019-03-23T00:00:00Z","relpermalink":"/post/zk_summit_3/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"Zero-knowledge summit - ZK0x03","type":"post"},{"authors":null,"categories":null,"content":"In my first post, we’ve seen that elliptic curves cryptography (ECC) was first introduced as a better alternative to public-key cryptography based on multiplicative groups of finite fields. In fact, ECC requires smaller keys compared to its finite field analog to provide equivalent security. Finite fields cryptosystems rely on the “hardness” of the discrete logarithm problem (DLP) to build cryptographic tools such as encryption (ElGamal), key exchange (Diffie-Hellman DH) and digital signature algorithms(DSA). Analogously, one expects to have ElGamal, DH and DSA counterparts thanks to the “hardness” of the equivalent elliptic curves discrete logarithm problem (ECDLP). However, it seems that only ECDH and ECDSA are popular. So, is there an ElGamal version for elliptic curves? Is direct encryption even possible with elliptic curves?\nThe use of elliptic curves in cryptography was suggested independently by Neal Koblitz and Victor S. Miller in 1985. The main reason was that previous asymmetric approaches were subject to subexponential-time index calculus algorithms that solve the underlying hard problems, whereas no subexponential-time algorithms are known for the discrete logarithm problem in a (suitably chosen) elliptic curve. Moreover, for the most part the best available algorithms are ones that have nothing to do with the specific structure of the elliptic curve group, but rather would work with essentially the same running time on any group. Such algorithms are said to be “generic”. In his paper, Koblitz suggested an encryption algorithm similar to ElGamal but it needed an invertible function to map plaintexts to points on an elliptic curve which made the scheme a bit impractical. The algorithm works as follows:\nWe set up an elliptic curve $E$ over a finite field $\\mathbb{F}_p$ and a point $P$ of order $N$. We need a public known invertible function $f$ that maps messages $m$ to points $P_m$ on $E$. We choose a random secret key $x \\in [1,N-1]$ and publish the point $Y=xP$ as public key. Encryption: We choose a random integer $k \\in [1,N-1]$, then calculate $C_1=kP$, $C_2=kY$ and $P_m=f(m)$. The ciphertext is the tuple $(C_1, C_2+P_m)$. Decryption: From the ciphertext $(C, D)$ we calculate $C\u0026rsquo;=xC$ and retrieve the point $P_m$ with $P_m=D-C\u0026rsquo;$ ($=k(xP)+P_m-x(kP)$). Finally, we recover the message $m$ with $f^{-1}(P_m)$. Basically, this is how we can do encryption on the elliptic curve but for real-world encryption this is somehow impractical because of the required invertible point mapping. One way to do it is interpreting the message as the $X$ coordinate of a curve point and computing a matching $Y$ coordinate. This has two drawbacks:\nFirst, only about half of the $X$ values can be the first coordinate of a curve point and second, one needs to compute a modular quadratic residue ($Y^2=X^3+aX+b$) to find the $Y$. This is not trivial and requires using Tonelli-Shanks algorithm. So, for things to work, some variability (some bits which can be adjusted until a possible $X$ is reached) would be needed and since the size of the message would be severely limited (no bigger than $p$) this is hardly worthwhile.\nFor these reasons, direct encryption using elliptic curve is not practical but one can use hybrid encryption instead. That is, using ECDH to produce a shared secret value that will be used as a secret for some symmetric encryption algorithm (e.g. AES). This is called Elliptic Curve Integrated Encryption Scheme (ECIES).\n","date":1546473600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546473600,"objectID":"bd8250d03349c8d868563d2fb09fcd23","permalink":"/post/encryption_ec/","publishdate":"2019-01-03T00:00:00Z","relpermalink":"/post/encryption_ec/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"Encryption using elliptic curves","type":"post"},{"authors":null,"categories":null,"content":"What does this title mean?\nWell, last week (October 30th, 2018), Apple published a security update for iOS 12.1 and macOS Mojave 10.14.1 that addresses an issue existing in the method for determining prime numbers. This method was implemented in Apple’s crytptographic library CoreCrypto which is used in many different cryptographic applications. Martin Albrecht, Jake Massimo and Kenny Paterson of Royal Holloway and Juraj Somorovsky of Ruhr University were issued the CVE-2018–4398 for discovering the pitfall. The full academic paper can be found here. According to the paper, an attacker may be able to exploit a weakness in the primality test to incorrectly identify prime numbers.\nSo what are prime numbers and why they are used in cryptography? How to efficiently test the primality of a number? and what would be the impact if composite numbers are incorrectly declared primes (Apple primes)?\nPrime numbers A prime number is a positive integer that has exactly two positive integer factors, 1 and itself. For example, if we list the factors of 28, we have 1, 2, 4, 7, 14, and 28. That’s six factors. If we list the factors of 29, we only have 1 and 29. That’s two factors. So we say that 29 is a prime number, but 28 isn’t. Primes are central in number theory because of the fundamental theorem of arithmetic: every natural number greater than 1 is either a prime itself or can be factorized as a product of primes that is unique up to their order.\nThere are infinitely many primes (Euclid gave a simple proof by contradiction or you can check more recent proofs using Euler product for the Riemann zeta function or the irrationality of $\\pi$ and Leibniz formula) but no known simple formula separates them from composite numbers.\nA deterministic straightforward method to check if an integer $p$ is prime is to test whether $p$ is a multiple of any integer between $2$ and $\\sqrt{p}$, but this method or any deterministic approach remains very slow when dealing with big numbers.\nPrimality tests Many popular primality tests are probabilistic tests because they provide provable bounds on the probability being fooled by a composite number. These tests use, apart from the tested number, some other numbers (witnesses) which are chosen at random; the usual randomized primality tests never report a prime number as composite, but it is possible for a composite number to be reported as prime. The probability of error can be reduced by repeating the test with several independently chosen values of witnesses . The basic structure of randomized primality tests is as follows:\nRandomly pick a number . Check some equality (corresponding to the chosen test) involving and the given number . If the equality fails to hold true, then is a composite number and the test stops. Repeat from step 1 until the required accuracy is achieved. After one or more iterations, if is not found to be a composite number, then it can be declared probably prime. Fermat Primality Test Fermat\u0026rsquo;s Little Theorem If $p$ is as prime number and $a$ is a positive integer less than $p$, then the remainder of $a^{p-1}$ devising by $p$ is $1$ i.e. $a^{p-1} \\equiv 1 \\pmod p$\nTest Algorithm If $p$ is the number which we want to test for primality, then we could randomly choose $a$, such that $a \u0026lt; p$ and then calculate $a^{p-1} \\equiv \\pmod p$. If the result is not $1$, then by Fermat’s Little Theorem $p$ cannot be prime. What if that is not the case? We can choose another $a$ and then do the same test again. We could stop after some number of iterations and if the result is always $1$ in each of them, then we can state that is probably prime. The more iterations we do, the higher is the probability that our result is correct.\nMiller-Rabin Primality Test Key Ideas Fermat’s Little Theorem. If $p$ is prime and $x^2 \\equiv 1 \\pmod p$, then $x \\equiv 1$ or $-1 \\pmod p$ The number we want to test its primality is necessarily odd, then $p-1$ is even and we can write $p-1 = 2^s d$ where $d$ is an odd number and $d ≥ 0$.\nIf $p$ is prime, then either $a^d \\equiv 1 \\pmod p$ as in this case, repeated squaring from $a^d$ will always yield $1$, so $a^{p-1} \\pmod p$ will be $1$; or $a^{2^r d} \\equiv -1 \\pmod p$ for some $r$ such that $0 \\leq r \\leq s$, as repeated squaring from it will always yield $1$ and finally $a^{p-1} \\equiv 1 \\pmod p$. If none of these hold true, $a^{p-1}$ will not be $1$ for any prime number (otherwise there will be a contradiction with fact #2).\nTest Algorithm Let be $p$ the given number which we have to test. First we rewrite $p-1$ as $2^s d$. Now we pick some in range and then check whether or for . If both of them fail, then is definitely composite. Otherwise is probably prime. We can choose another and repeat the same test to reduce the probability of error.\nApple’s pitfall In number theory, a Carmichael number is a composite number $n$ which satisfies the modular arithmetic congruence relation $a^{p-1} \\equiv 1 \\pmod p$ for all integers $a$ which are coprime to $n$, i.e. a composite number that satisfies Fermat’s test. Robert Carmichael found the first and smallest such number, 561, which explains the name \u0026ldquo;Carmichael number\u0026rdquo;. Indeed, $561=3 \\times 11 \\times 17$ and $a^{560} \\equiv 1 \\pmod{561}$ for all $a$ coprime to $561$.\nLike the Fermat, the Rabin-Miller test has Carmichael numbers (choices of $a$ for which the test declares a composite integer to be a probable prime) but there are fewer. It turns out for any composite $n$, including Carmichael numbers, the probability $n$ passes the Miller-Rabin test is at most 1/4 (on average it is significantly less.) Thus the probability $n$ passes several runs decreases exponentially. However, the bases $a$ should be chosen randomly so an attacker wouldn’t be able to find Carmichael numbers with respect to these bases.\nIn corecrypto library, Apple performs $t \u0026lt; 256$ rounds of Miller-Rabin testing, selecting the bases incrementally from a hard-coded list of the first 256 primes. When performing, for instance, $t = 32$ rounds of testing, the probability of a false prime classification is estimated as 1/$2^{64}$. However, since the bases $a$ generation is deterministic, an attacker should be able to find composite numbers that fool the test. This was done in the paper using the method described in Arnault, F \u0026ldquo;Constructing Carmichael numbers which are strong pseudoprimes to several bases\u0026rdquo; paper. An example of such a composite 1024-bit number of the form $n=p \\times q \\times r$ is given below:\nn = 105216055594390884840438324972769319399722594046651360392070071794973423530188471087867855419188813164954561140227145977855514336985746250989366318940490798583710597151720075427387437940535767395296272532149397065590267303873620351321073058502920032770522836726669005262088263964215455869031740912313201227043 with\np = 123282949929736752510916282638002560328626287433241467864741378859343760091491850110380631340085554443 q = 28724927333628663335043493854654596556569924971945262012484741274227096101317601075718687102239934184987 r = 29711190933066557355130824115758617039198935271411193755402672305101846182049535876601732152960618620523 ","date":1541462400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1541462400,"objectID":"58aff2179b5ff6b9bdf9ecad4d99e9ea","permalink":"/post/apple_primes/","publishdate":"2018-11-06T00:00:00Z","relpermalink":"/post/apple_primes/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"Apple primes","type":"post"},{"authors":null,"categories":null,"content":"Not to toot my own horn here but when I was in high school I used to be quite popular :). I was moreover one of the least shy people I know but when it came to girls, I was interested in, I suddenly turn to this timid shell of a person. This awkward version of a popular guy is not uncommon and the fear of rejection is the reason that rattles us to the core. I still remember this girl from my high school I’ve never talked to, because of that fear — let’s call her Salma in the sequel (Any resemblance to actual persons, living or dead, is purely coincidental). No matter how much courage I’ve summoned and how firmly I’ve convinced myself I don’t care about the outcome, hearing no from Salma would have hurt. A graceful no hurts a great deal less but a cruel no in public drives a knife through the male psyche.\nGrowing up, I became a cryptographer and figured out a mathematical way to deal with such a situation. How can you make secure advances to Salma ? Is there a way to securely guess the outcome ? or simply put, how can you avoid a dismissive no in public ? The solution uses Yao’s Garbled circuits for secure two-party computation (S2PC).\nGiven private inputs $x$ and $y$ and a public function $f$, this method enables two parties to securely compute the outcome $f(x,y)$ without revealing the secrets $x$ and $y$. A circuit is just a way to represent a computation consisting of just operations on bits, like AND, OR, NOT and a garbled circuit is a way to “encrypt a computation” that reveals only the output of the computation, but reveals nothing about the inputs or any intermediate values. Our situation makes the basic way to understand how the protocol works. Let the secret $x$ be 1 if I am interested in Salma and 0 otherwise. Similarly, her secret $y$ is either 1 or 0. We want to securely compute a function that outputs 1 if we both are interested in each other and 0 otherwise — no one should be able to guess the inputs. A simple function would be an AND gate.\nThere are 4 possibilities in the truth table but only one is the actual reality. Next, we “garble” this circuit as follows: For each wire $x, y$ and z, we specify two random values corresponding to 0 and 1 and then we encrypt (using some symmetric cipher such as AES) the truth table by encrypting the output-wire key with the corresponding pair of input-wire keys. Which results in the Garbled Computation Table (GCT).\nGiven two input keys only one row of the GCT can be decrypted correctly. Next, we rearrange the GCT — so that no information is leaked — and send it to Salma along with my input key. Note that, since the key is random, there is no way to associate it with the actual bit. At this point, she has the GCT and my input key but needs the key I have already associated to her input bit. But just like me, Salma doesn’t want to reveal her secret (bit)! Neither want I to send her both keys, as she would be able to decrypt more than a GCT row. What we need here is a protocol in which a sender transfers one of potentially many pieces of information to a receiver, but remains oblivious as to what piece has been transferred. Fortunately, such a protocol exists and is called 1-out-of-2 oblivious transfer (OT). In the next section, I will present a simple 1–2 OT protocol but if you don’t know how RSA encryption works just skip this section since explaining it goes beyond the scope of this post.\n1–2 Oblivious Transfer Alice holds $m_0, m_1$, and an RSA key pair $(e, d, N)$. Bob holds the public key $(e, N)$ of Alice, $x \\in {0,1}$ and wants $m_x$ Alice generates random $x_0, x_1$ and sends them to Bob Bob chooses a random $k$, computes $v=y_x+k^e$ and sends $v$ to Alice. Alice computes $k_0=(v-x_0)^d$ and $k_1=(v-x_1)^d$, and sends $m_0\u0026rsquo;=m_0+k_0$ and $m_1\u0026rsquo;=m_1+k_1$ to Bob Bob computes $m_x=m_x\u0026rsquo;-k$ and learns nothing about $m\u0026rsquo; _{1-x}$ Now, using 1–2 OT protocol, Salma can have her input key without me knowing anything about her secret bit. At this point, we can decrypt the GCT row corresponding to our secrets and reveal securely the output value. If it is a 0, none is able to tell who rejected the other and if it is a 1… Jackpot!\nBy and large, this is how we can do secure two-party computation. So, dear Salma, if by any chance you’re reading my post, here is my secret key ;)\n0x3361736861206c6d616c69696969696b ","date":1540166400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540166400,"objectID":"4554f84e94618e99903e23bdeb2c6ce0","permalink":"/post/s2pc/","publishdate":"2018-10-22T00:00:00Z","relpermalink":"/post/s2pc/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"Secure Two-Party Computation (S2PC)","type":"post"},{"authors":null,"categories":null,"content":"Every name tells a story. If you ask new parents \u0026ldquo;how did you choose your baby’s name?\u0026rdquo; sometimes the response will be a vague \u0026ldquo;Oh she chose!\u0026rdquo; but most of the time there is a story behind, and it’s often a great story about going through dozens of possibilities until one clicked. It goes from her favorite fictional character to her favorite great-aunt, so the baby has to be called Khaleesi. Obviously. In mathematics, it is no different. When mathematicians introduce their new baby to the world, they choose an appropriate name far from being random. In my last post, I have talked about elliptic curves and why they are used in cryptography. This triggered the question on why they are called \u0026ldquo;elliptic\u0026rdquo; even though they do not resemble ellipses in any way.\nElliptic curves are of cubic equations $y^2=x^3+ax+b$ while ellipses are of quadratic equations $x^2/a^2+y^2/b^2=1$. So, prima facie, there is no connection between them. But looking deeply into the history of elliptic curves, one finds out the connection. In the 18th century it was natural to ask about the arc length of an ellipse. In fact, despite their similarity to circles, ellipses are quite different. For example, a circle’s circumference is given by $2 \\pi r$ and its area by $\\pi r^2$ where $r$ is the radius. It is remarkable how the constant $\\pi$ relates the circumference to the area given the radius $r$. But things are not that easy when dealing with ellipses. Given $a$ and $b$ as the semi-radii, the area of an ellipse is $\\pi ab$ but the circumference is a more difficult question. More generally, the arc length of ellipses is difficult to calculate and is given either by a hard integral or by a rather formidable series. This question led to the study of $\\sqrt{f(x)}$ where $f(x)$ is a polynomial of degree 3 or 4. These functions cannot be described with familiar calculus functions and came to be known as elliptic integrals. For circles, $f(x)$ is a quadratic polynomial and we get \u0026ldquo;circular integrals\u0026rdquo; which are easy to handle. for example, we know that $\\int dx / (\\sqrt{1-x^2}) = \\sin ^{-1} (x)$ and the inverse of the function, namely $\\sin{x}$, is well studied and easy to deal with. Thus, circular integrals lead to the periodic trigonometric functions. Similarly, studying the inverse of elliptic integrals leads to some doubly periodic functions which came to be known as elliptic functions (let’s call them ℘(z) in the sequel, because ℘ looks nice). Furthermore, all the derivatives are doubly periodic with the same periods and satisfy a cubic differential equation. Now in calculus, you learn about parametric equations and how they can describe a curve. By a parameterization of a curve $C$, we mean a continuous bijection from a set of numbers to the set of all points on $C$. For example, letting $x=a \\sin{t}$ and $y=b \\cos{t}$ with $t \\in [0, 2 \\pi)$ gives a familiar parameterization of the standard ellipse $x^2/a^2+y^2/b^2=1$. In the same way, we see that setting $x=℘(z)$ and $y=℘’(z)$ gives a parameterization of the cubic curve known today as an elliptic curve. Names are reservoirs of stories and this was the story behind elliptic curves’ name.\nOne last thing before I forget, dear future son, if this post lives long enough so that you are reading it now, I am sure you will understand why I called you Jon Snow. But for now, you know nothing Jon Snow.\n","date":1539475200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1539475200,"objectID":"70b153962b3ce0502a99fe04360559b0","permalink":"/post/ellipse/","publishdate":"2018-10-14T00:00:00Z","relpermalink":"/post/ellipse/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"Why elliptic curves are called \"elliptic\" ?","type":"post"},{"authors":null,"categories":null,"content":"In the series of posts I am willing to write, I will try to answer technical questions I have been asking myself throughout my readings about Maths, cryptography and Blockchain. For many questions, I couldn’t find easily or completely the answer I was looking for. One of these questions I faced is: Why did we even consider using elliptic curves for cryptography ? The question is \u0026ldquo;Why\u0026rdquo; rather than \u0026ldquo;How\u0026rdquo;. Elliptic curves are mathematical objects from the algebraic geometry and one should be normally surprised when discovering that such objects are used to encrypt data. In fact, elliptic curves are non-singular algebraic curves satisfying an equation of the form $y^3=x^3+ax+b$ (cf. figure 1).\nFigure 1: Examples of elliptic curves over $\\mathbb{R}^2$ Well, that doesn’t help us a lot.. And since I started this post with a question you have the right to ask more questions: What do these mathy words mean? How did we get this equation? And why are they even called \u0026ldquo;elliptic\u0026rdquo; even though they do not resemble \u0026ldquo;ellipses\u0026rdquo; in any way ? Don’t worry I’ve asked myself these same questions and we’re going to deep dive into the answers in later posts. For now, let’s go back to the main question: Why do we use these curves to encrypt data? To answer this we have to trace the evolution of cryptography over the years. The earliest known cryptographic schemes use a symmetric approach — that is using the same key for both encryption and decryption. A simple example of this approach and one of the oldest would be \u0026ldquo;Caesar cipher\u0026rdquo; in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. In this scheme the encryption/decryption key is the fixed number of positions that must be kept secret and known only to the communicating parties. This symmetric approach is still widely used today through many ciphers such as AES, Blowfish or RC4 but the requirement of a secret symmetric key is still the main drawback. Cryptographers have been then looking for innovative asymmetric approaches where the decryption key differs from the encryption one. That is said, they have been looking for algorithms where it is easy to derive the decryption key (public) given the encryption key (private) and difficult the other way around — or mathematically put, a function that is straightforward to compute and computationally hard to inverse. One of the first algorithms proposed and still widely used nowadays is the famous RSA which relies on the hardness of the \u0026ldquo;factorization problem\u0026rdquo;. In fact, given two prime integers, it is easy to compute their multiplication but presumably hard to find the prime integers given the multiplication output. At this point you may (should) be asking why is it hard to factorize an integer and the answer is that there is no published algorithm that can do this in polynomial time (an algorithm is said to be of polynomial time if its running time is upper bounded by a polynomial expression in the size of the input for the algorithm). In fact, the best published asymptotic running time (on a classical computer, not a quantum one. Wait, quantum?) is for the general number field sieve (GNFS) algorithm which has a sub-exponential complexity. In short, integer factorization is \u0026ldquo;hard\u0026rdquo; in the sense of computational efficiency because we haven’t found just yet a reason for it to be easy, and we can’t prove it is hard. All this to come to the point that integer factorization, in my opinion, has nothing to do with the unknown primes distribution as widely believed. It is true that the problem is built upon the fundamental theorem of arithmetic which states that every integer can be uniquely represented as the product of prime numbers but I think that the chaotic nature of primes distribution has no bearing on the problem. There’s no reason to expect that factorization would become even a bit easier by proving the Goldbach conjecture, the twin primes conjecture or the Riemann Hypothesis for examples. However, the problem becomes computationally easier (polynomial time) when using quantum computers to run Shor’s algorithm as we will see on a later post. Another proposed asymmetric construction relies on the hardness of the \u0026ldquo;discrete logarithm\u0026rdquo; problem in cyclic groups. Given integers a and b in a carefully chosen group G, no efficient method is known for recovering the integer k such that $a=b^k$. In fact, the problem is quickly computable in a few special cases but in some cases there is not only no efficient algorithm known for the worst case, but the average-case complexity can be shown to be about as hard as the worst case using random self-reducibility. So choosing the group G is critical and a popular choice that provides good security assumptions is large prime order subgroups of groups $\\mathbb{Z}_p$. These groups were used to build several known cryptographic protocols such as ElGamal encrytpion, Diffie-Hellman (DH) key exchange and Digital Signature Algorithm (DSA). However, using these groups requires large key sizes because of the sub-exponential GNFS algorithm as well. In fact, while computing discrete logarithms and factoring integers are distinct problems, both are special cases of the hidden subgroup problem for finite Abelian groups and thus, for both, the most efficient approach remains GNFS on a classical computer and Shor’s algorithm on a quantum computer. At this point, you may be thinking that somehow changing that group G from finite fields to elliptic curves may provide better security assumptions. You’re right! The best published algorithms to find discrete logarithms over elliptic curves are Pollard’s $\\rho$ or baby-step-giant-step with a way better running time than GNFS. But wait, what is a discrete logarithm over elliptic curves? (you ask a lot of questions, huh?) Well, no worries, we will soon deep dive into all the machinery ;)\n","date":1538870400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538870400,"objectID":"36a4779f351f91c86c19765e9dd3f864","permalink":"/post/why_ec/","publishdate":"2018-10-07T00:00:00Z","relpermalink":"/post/why_ec/","section":"post","summary":"From my Medium blog - medium.com/@youssef.housni21","tags":null,"title":"Why do we use elliptic curves for cryptography?","type":"post"},{"authors":["Youssef El Housni","Youssef El Housni","Youssef El Housni","Youssef El Housni","Youssef El Housni","Youssef El Housni","Youssef El Housni","Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1537228800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1537228800,"objectID":"a00ea4254e7c829eee0001927408e2d0","permalink":"/publication/journal/mdpi18/","publishdate":"2018-09-18T00:00:00Z","relpermalink":"/publication/journal/mdpi18/","section":"publication","summary":"MDPI Cryptography 2018, 2(3) (Special Issue Code-Based Cryptography)","tags":null,"title":"On the Performance and Security of Multiplication in $GF(2^N)$","type":"publication"},{"authors":["Youssef El Housni","Youssef El Housni"],"categories":null,"content":"","date":1536796800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1536796800,"objectID":"71e4077c31787e1f6d490b423460e8fb","permalink":"/publication/conference/fdtc18/","publishdate":"2018-09-13T00:00:00Z","relpermalink":"/publication/conference/fdtc18/","section":"publication","summary":"FDTC 2018","tags":null,"title":"Random Numbers Generation: Tests and Attacks","type":"publication"}]